


{
  "pages": [
    {
      
      
      
      "content": "\n",
      "url": "/404.html"
    },{
      
      "title": "About",
      "description": "Resume\n",
      "content": "Software Engineer－軟體工程師\n\n\n\n\n\nWork Portfolio\n\n近年主要專注在“互動軟體研發”，參與過 Whiteboard 電子白板、NovoDS Cloud 雲端數位看板系統、GPIO 感測器控制、遠端會議系統、軟體 CI &amp; 許可證管理後台。上一份工作專案包含「Ai+數據引擎，跨國電商，GA廣告追蹤系統、CRM系統、人才庫系統、NIKE.vn &amp; Golf」等平台前端開發。\n\n【設計思考的啟發】\n\n最早接觸到UIUX領域是任職數位設計公司期間，所屬團隊是由一位義大利籍女藝術總監負責，在她的西式帶領下給了我相當大的影響，總監對專案非常細心負責，也鼓勵我們要有國際視野，並多體驗生活美感提高設計經驗。更了解幾項重要設計原則如：UCD使用者為中心出發、好的設計是使產品易於理解、Design Guideline設計一致性等，透過在不同文化及扎實的實務經驗中，啟發了我對設計思考的看法，了解設計不僅是外觀和感覺，設計就是它的工作方式。\n\n【從前端工程到軟體開發】\n\n近五年的工作經驗與電子科技領域相關，開發過線上雲端軟體、多樣性的前後台網站至B2B的中小企業AI+智能數據服務系統。回顧過去曾任職威剛集團專案的技術經理負責主導平台開發，從無到有並透過研究訪談利害關係人、網站用戶及專業醫療人員，協同工程部、藥師和業務團隊進行功能規劃，如：在線諮詢和醫生預約系統、查藥APP、社群互動功能以及電子商務系統。累積了豐富的專案開發經驗，同時也積極學習其他網頁技術，SEM、Website Meta及Google Optimize、GA、GTM等分析操作，配合集團產品電子商務操作行銷活動，解決網站導入使用介面等問題。這些寶貴的經驗讓我開始負責管理層面的工作，對我而言，積極、主動、負責一直是自己面對工作的態度，保持彈性勇於嘗試付出，才能扮演好自己的角色為團隊加分！\n\n\n\n[Inspiration from design thinking]\n\nThe first time I came into contact with the UIUX field was when I was working in a digital design company. The team I belonged to was headed by an Italian female art director. Her Western-style leadership had a great impact on me. The director was very enthusiastic about the project. Being careful and responsible also encourages us to have an international perspective, experience more of the beauty of life and improve our design experience. I learned more about several important design principles such as: UCD user-centered approach, good design is to make the product easy to understand, Design Guideline design consistency, etc. Through different cultures and solid practical experience, it inspired me to think about design. perspective, understanding that design is not just about how it looks and feels, design is how it works.\n\n[From front-end engineering to software development]\n\nThe past five years of work experience are related to the field of electronic technology. I have developed online cloud software, diverse front-end and back-end websites, and B2B small and medium-sized enterprise AI+ intelligent data service systems. Looking back on the past, I worked as a technical manager for ADATA Group projects and was responsible for leading the development of the platform from scratch. Through research and interviews with stakeholders, website users and professional medical personnel, I collaborated with the engineering department, pharmacists and business teams to carry out functional planning, such as: Online consultation and doctor appointment system, drug search APP, social interaction function and e-commerce system.\n\nHe has accumulated rich experience in project development, and is also actively learning other web page technologies, SEM, Website Meta and Google Optimize, GA, GTM and other analysis operations, cooperating with the group’s product e-commerce operations and marketing activities, and solving problems such as website import and user interface. These valuable experiences allowed me to take charge of management-level work. For me, being positive, proactive, and responsible has always been my attitude towards work. Only by remaining flexible and having the courage to try and give can I play my role well and add points to the team!\n\n",
      "url": "/about/"
    },{
      
      "title": "Blog Catalog",
      
      "content": "\n",
      "url": "/blog/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/"
    },{
      
      "title": "Posts",
      "description": "This is the list layout for showing blog posts, which shows just the title and groups them by year of publication. Check out the blog layout for comparison.\n",
      "content": "\n",
      "url": "/posts/"
    },{
      
      "title": "Projects",
      "description": "Welcome to my portfolio! Here, you will find a curated selection of my work, showcasing my skills and experience in software engineering and design. Over the years, I have had the opportunity to work on a variety of projects, ranging from interactive software development to cloud-based digital signage systems. My portfolio highlights my expertise in front-end and back-end development, as well as my ability to manage and lead complex projects.\n",
      "content": "\n",
      "url": "/projects/"
    },{
      
      "title": "Resume",
      "description": "Resume\n",
      "content": "Skills\n\n\n  參與 UI/UX 介面設計與 PM 以及後端工程師討論資訊架構以及專案時程\n  擅長跨平台軟體開發 Electron、Vue、React、Nodejs、JS、JQ、TypeScript、Vite 進行產品開發。\n  使用基於 Vue.js 的框架的 SSR 技術 Nuxt.js 或 React Next.js 技術。\n  Cypress、Nghtwatch E2E 測試及 SVN、Git 或 Sourcetree 等版本控管工具。\n  使用瀏覽器開發者工具評估程式運行效能，減少重新渲染，降低資料處理複雜度。\n  與測試工程師合作，進行 bug 修正或是與 PM 討論規格變更。\n\n\nTOOLS SUMMARY\n\n[Develop Language] Html5, CSS3, JS, JQ, Sass, Scss, Stylus, Tailwind CSS\n[Develop Framework] Vue.js, React.js, Nuxt.js, Next.js, Node.js, Fabric.js, WebSocket\n[UI Framework] Quasar, Vuetify, MUI, Ant Design, Element UI\n[UI Design] Figma, Adobe XD, Invision, Sketch, Zeplin\n[UX] Persona, User Story Mapping, Functional Map\n[Visual Processing] Illustrator, PhotoShop, InDesign, Lightroom, AE, Premiere, DaVinci\n[3D Motion] Poser, MAYA, SketchUp\n\nExperience\n\nDelta Electronics\nAug 2022 - Now\nSenior Software Engineer\n\neForce Taiwan Technology\nJul 2020 - Jul 2022\nSenior Frontend Developer\n\nADATA Group _ We-Lead Bio Technology\nJan 2015 - Apr 2020\nTeam Manager\n\nTowan Digital Imaging\nOct 2009 - Apr 2013\nWeb Design Engineer\n\nXigu Culture Communication\nNov 2005 - Jun 2008\nProject Assistant\n\nEducation\n\nNTUST, Taipei\nSep 2004 - Jun 2008\nDepartment of Commercial Design\n\nFu-Hsin Trade &amp; Arts School\nSep 2001 - Jun 2004\nArt Department\n\nAwards\n\n\n  The 5th Nominated for the Czech AniFest International Animation Film Festival\n  The 12th National Technical College Computer Animation Competition\n  2008-YODEX New Generation Design Exhibition\n  The 8th Business Design Graduation Exhibition of Taiwan University of Science and Technology\n  Taiwan University of Science and Technology Campus Design Competition\n\n\nPublishing\n\n\n  “行走的博物馆指南” - 浙江人民美術出版社\nNov 2020 / Book / Language: Simplified Chinese\n  “瘋玩世界級博物館｜The World’s Top Museum” - Uni-Booking Publishing\nMay 2018 / Book &amp; Ebook / Language: Traditional Chinese\n  “巴黎夢幻自助婚紗｜Wedding photography in Paris” - Farreaching Huacheng Publishing\nOct 2014 / Language: Traditional Chinese\n\n\nCertification\n\n\n  Google Analytics (分析) 個人認證資格\n  Google Ads 搜尋廣告認證\n  JavaScript Algorithms and Data Structures\n\n\n\n\n",
      "url": "/resume/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/2/"
    },{
      
      "title": "Blog",
      "description": "The official Hydejack blog. Version updates, example content and how-to guides on how to blog with Jekyll.\n",
      "content": "\n",
      "url": "/3/"
    }
  ], 
  "documents": [
    {
      "image": "https://img.freepik.com/free-photo/grandparent-learning-use-technology_23-2149402632.jpg?w=1380&t=st=1726317294~exp=1726317894~hmac=4c9492370078736b92ec7784e2dc3c0cc81e8ae3b45c5c9af8881b51cd0fb66e",
      "title": "程式開發之路：前端還是後端？我的職涯抉擇",
      "date": "2018-04-30 00:00:00 +0800",
      
      "content": "\n  雄心壯志：全端工程師夢\n  迷茫時期：前端的價值何在？\n  重新定位：發掘自我價值    \n      前端：表面簡單,內涵豐富\n      全端發展：權衡與選擇\n    \n  \n\n\n\n  站在職涯的十字路口,我不禁陷入了深思。作為一名網頁開發新手,該往前端還是後端方向邁進?這個問題困擾著我。回想起來,我的程式之旅始於前端,因為它能迅速呈現成果,給予我極大的成就感。然而,隨著時間推移,我開始探索後端領域,希望能夠全面掌握網頁運作的奧秘。\n\n\n雄心壯志：全端工程師夢\n\n初入程式世界,我雄心勃勃,立志成為一名全能的全端工程師。這個目標看似完美,直到我偶然看到一句話：”自稱全端的人往往樣樣通,樣樣鬆”。這句話如當頭棒喝,促使我重新審視自己的職涯規劃,也讓我開始深入探索網路開發的生態系統。\n\n迷茫時期：前端的價值何在？\n\n在研究過程中,我驚訝地發現網路上充斥著對前端開發者的質疑聲音。主要論點包括：\n\n\n  入行門檻低,人人都可以做\n  不需要深厚的計算機科學基礎\n  市場飽和,出現所謂的”前端難民”現象\n\n\n這些言論讓我陷入了自我懷疑：選擇前端作為職業發展方向,我真的能在這個領域有所作為嗎？\n\n重新定位：發掘自我價值\n\n經過一番深思熟慮,我逐漸找到了答案。\n\n前端：表面簡單,內涵豐富\n\n深入了解後,我發現前端遠非外界想像的那樣簡單。近年來,前端技術日新月異,PWA、跨平台開發、WebAssembly等新技術層出不窮。瀏覽器功能日益強大,推動了前端的無限可能。性能優化成為關鍵課題,傳統網站正逐步被功能強大的Web應用取代。\n\n我有幸在實習期間遇到了卓越的導師和優秀的團隊,他們讓我領悟到高質量代碼和優秀架構設計的重要性。這些經歷使我確信：在技術領域,價值源於個人的不斷探索和創新。\n\n就前端工程師而言,有人專注於技術架構,有人擅長用戶體驗設計,每個人都能在自己的專長領域創造獨特價值。關鍵在於找准自己的定位,滿足市場的多元需求。\n\n全端發展：權衡與選擇\n\n經過深思,我認識到在有限時間內同時精通前後端確實極具挑戰。因此,我決定先在一個領域深耕細作,選擇最適合自己的發展方向。但這並不意味著要放棄學習其他技能。\n\n如今,當被問及職業時,我會這樣回答：「我是一名網頁開發工程師,專注於前端技術,同時也在不斷學習後端知識。」我相信,一個優秀的前端工程師應該了解數據處理的原理,同樣,一個出色的後端工程師也應該關注數據在前端的呈現效果。這種全面的視角對於打造優質產品至關重要。\n\n未來的道路還很長,也許幾年後我的職位會有所變化。但最重要的是,我不能忘記初心——用技術解決實際問題,分享知識,推動行業進步。最關鍵的是,保持對這個領域的熱愛和探索精神。我堅信,只要堅持不懈,終會在這個充滿機遇的行業中找到屬於自己的一席之地。\n",
      "categories": ["blog","職涯規劃","程式開發"],
      "tags": ["前端工程","後端工程","全端開發"],
      
      "collection": "posts",
      "url": "/blog/%E8%81%B7%E6%B6%AF%E8%A6%8F%E5%8A%83/%E7%A8%8B%E5%BC%8F%E9%96%8B%E7%99%BC/2018-04-30-blog-F2E/"
    },{
      "image": "https://frank198978104.github.io/images/2017-07-28-welcome-to-jekyll/2017-07-28-welcome-to-jekyll-image0.jpg",
      "title": "好用的 Github Pages & jekyll 介紹",
      "date": "2018-06-01 00:00:00 +0800",
      
      "content": "\n  什麼是 Jekyll ?    \n      打算使用 Jekyll 的朋友們，會建議熟悉 Git &amp; Html &amp; Markdown\n    \n  \n  使用的 Jekyll 特色呢?\n  Github Pages &amp; jekyll 技術介紹\n  強大特色\n  Jekyll 官方介紹\n  jekyll-theme\n  Github Page\n\n\n來說說 Github Pages 與 jekyll 好用的部落格功能吧~\n\n什麼是 Jekyll ?\nJekyll是基於Ruby Gem的解析引擎，能夠將樣板、liquid 語言、markdown轉換為 靜態網頁 的產生器。\n\n打算使用 Jekyll 的朋友們，會建議熟悉 Git &amp; Html &amp; Markdown\n\n使用的 Jekyll 特色呢?\n\n  No more databases 不需要資料庫\n  Liquid Template 動態模板\n  Free hosting with GitHub Pages 只要學會git push 就可以丟到github page上\n  Markdown 好編寫\n\n\nGithub Pages &amp; jekyll 技術介紹\nGit, Github, Github Pages\nGit版本控制工具，Github是使用git版本控制項目的的虛擬主機服務\n \n\n連結在此：http://pages.github.com/\n\nGithub Pages 是 Github 提供的服務，可以利用 Repository 建立自己的靜態頁面，其中不需要任何 databases 的 Jekyll 強大功能，在每次的 git push 後會將 markdown 轉換為頁面，所以 Jekyll 是很適合用來建立部落格等內容！\n\n強大特色\n\n\n  快速 html靜態頁就是快速。\n  穩定 ”github” 這個品牌能不信嗎?\n  完全免費，可惜大部分的模板不怎麼美就是了…\n  容量無限 只要會git commit、git push。\n  Markdown是一種輕量級標記式語言，他在編寫完後就像是一般的文字檔，也可轉換成有效的XHTML（或者HTML）文件。\n  其易懂易讀的語法都是用標點符號組成，方便作為網站blog的寫作語言。附上相關範例 http://markdown.tw/\n\n\nJekyll 官方介紹\n可於官網下來或在 git hub 搜尋相關主題下載下來使用，其資料夾編寫後會產生(如：_site等資料夾)，再將此資料夾的靜態網頁上傳於 Repository 即可。\nhttps://jekyllrb.com/\n\njekyll-theme\nJekyll所使用的樣板語言是使用 Ruby 編寫，透過渲染器運行生成為靜態網站。本地端需要下載 ruby 來運行。以下官方提供模板範例可下載使用。\nhttps://www.ruby-lang.org/zh_tw/\nhttps://github.com/topics/jekyll-theme\n\nGithub Page\n在發布Repository後，之後每次都只需要在本地端push文章就可以了！而每次push到github上的文章及Template，都會透過Jekyll server轉換為靜態的網站。\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2018-06-01-blog-Jekyll/"
    },{
      "image": "https://lh3.googleusercontent.com/fAQAzXOc_vdu9y9UjXqvGqWbaL0bdJq1CCxljUModhJUA0trlXlHs8gMiOZwcDM_g94h1w9rjIz6YKJqTqpQKmWydv5nNohvkd-x_EkkPbJCzbgtDSQ=s0",
      "title": "善用Google Sheet作為你的簡易表單資料庫！",
      "date": "2018-08-05 00:00:00 +0800",
      
      "content": "\n  客製化表單上傳至Google Sheet\n  步驟1. 建立一個Google表單\n  Google表單連結Google Sheet    \n      進入後開啟瀏覽器的開發者工具\n      在form元素內層可以找到幾個隱藏的input\n    \n  \n  POST請求\n  小結\n\n\n今天我想分享一個既有趣又實用的應用，就是利用Google Sheet來充當表單內容的資料庫。我想許多讀者會猜測這將會是一個麻煩的過程，可能要經過許多繁雜的設置，不過事實是…\n其實非常簡單又方便\n如果想一探究竟的讀者就繼續往下看吧！\n\n客製化表單上傳至Google Sheet\n為什麼要這麼做？\n基本上大部分的事情都是先有需求，再去因應需求找出對應的解法。因此今天在說明該怎麼做到把Google Sheet當作客製化表單資料庫以前，我們得先談談這樣的方法適合應用在哪些使用情境上。\n大部分企業幾乎都會有自己的形象官網，而通常官網也會與企業提供的服務分開，為單純以展示資訊為主要目的的靜態形象頁面。同樣性質的網頁還有特定活動的宣傳網站，也是以展示活動資訊為主要目的，與網頁應用程式（web app）有很大的區別。不過雖然是以呈現資訊為主，這類型的網站通常會有一個例如「聯絡我們」的區塊，讓使用者填寫自己的聯絡資訊，搜集顧客資訊以挖掘更多潛在的商機，例如知名電動車品牌Tesla的官網：\n\n我們都知道通常表單的運作是在提交時會發一個POST請求到後端API，再將資料儲存到後端資料庫裡。但是如果因為團隊人力配置因素或是開發者本身技術限制，沒辦法生出這樣一個API的話該怎麼辦呢？又或者即使有這樣的API，但要運用這些資料的人反而是非工程團隊的夥伴時，請他們下SQL查詢去撈資料好像又不是那麼實際或方便（當然還是有很多能協助達成這件事的工具啦），這時候如果採用文章標題的方法似乎蠻可行的：將客製化的表單內容上傳至Google Sheet中。像這樣資料提交數量不會很大的情況，就很適合這樣的做法，Google Sheet的操作介面也十分平易近人，適合所有人來使用。\n了解這個方法適用的情況後，讓我們開始動手做吧！\n\n\n步驟1. 建立一個Google表單\n是的，你沒有看錯，不是Google試算表，是Google表單(Google Form)。在我們從客製化表單點擊提交後，我們會對一個URL發一個POST請求，這個URL就是Google表單的連結，URL中我們會帶查詢字串，我們都知道查詢字串會是鍵值對的形式，這邊的鍵會是Google表單各欄位的ID，值則是我們從客製化表單收集到的資訊，當我們完成這個請求後，就會自動將資料回覆到Google表單中，接著就是Google服務強大的地方了，它可以將Google表單收到的回覆同步到一個Google Sheet中，如此一來Google Sheet就成為一個簡單的儲存庫了。\n讓我們總結一下這個方式\n從客製化表單按下送出按鈕後，會對Google表單發一個POST請求，以查詢字串的方式將資料帶到Google表單回覆中，再利用Google服務相通的功能，將資料同步儲存到Google Sheet中。\n不過其實除了一開始設定以外，之後的流程都可以忽略Google表單那層，我們可以看成從客製化表單送出後，資料就直接存到Google Sheet裡面了。\n\n（在開始之前記得將表單權限設為所有人都可以存取喔！）\n在建立Google表單之後，就可以來建立問題欄位，注意囉，這邊的欄位要跟你網頁上客製化表單的欄位一樣喔！這邊因為示範方便所以隨便新增兩個欄位。\n接著點選回覆的分頁，有個Google Sheet的圖示，點擊創建一個與這個表單連結的試算表（其實也可以連結現有表單不需重新建立）\n\n\nGoogle表單連結Google Sheet\n接下來我們需要取得兩個東西：\nGoogle表單的ID\n表單中各欄位的ID\nGoogle表單的ID\n\n先點選右上角的「傳送」按鈕，再點選連結的傳送方式，會出現一段URL，以示範裡的例子來說，URL為\nhttps://docs.google.com/forms/d/e/1FAIpQLSfniOOcWIeG4FsL14tqLoEfqz9oRYuGru8rwMvOhH2vs7UPPg/viewform?usp=sf_link\n我們要的form ID即為/e後的那段字串，即是\n1FAIpQLSfniOOcWIeG4FsL14tqLoEfqz9oRYuGru8rwMvOhH2vs7UPPg \n表單中各欄位的ID\n我們得取得Google表單中各欄位的ID，才能在POST請求時正確傳資料到該欄位，首先先進入上面拿到的用來分享表單的連結\n\nhttps://docs.google.com/forms/d/e/1FAIpQLSfniOOcWIeG4FsL14tqLoEfqz9oRYuGru8rwMvOhH2vs7UPPg/viewform?usp=sf_link\n\n進入後開啟瀏覽器的開發者工具\n\n在form元素內層可以找到幾個隱藏的input\n\nentry.979040326與entry.589442071就是我們要找的欄位ID，注意這邊隱藏input的順序是跟表單欄位的順序一樣的喔！\nPOST請求\n必要的資料都拿到後就可以試著在客製化表單送出時發出POST請求了\n\nimport { stringify } from 'qs';\n\n// 上傳數據到Google表單的函數\nexport const uploadToGoogleSheet = (formId: string, query: Record&lt;string, unknown&gt;): Promise&lt;void&gt; =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    fetch(`https://docs.google.com/forms/d/e/${formId}/formResponse?&amp;${stringify(query)}&amp;submit=SUBMIT`, {\n      method: 'POST',\n      mode: 'no-cors', // Google只接受'no-cors'模式的表單提交\n      redirect: 'follow',\n      referrer: 'no-referrer',\n    })\n    .then(() =&gt; resolve())\n    .catch(() =&gt; reject());\n  });\n};\n\n// 處理表單提交的函數\nconst handleSubmit = (values: any) =&gt; {\n  const FORM_ID = '1FAIpQLSfniOOcWIeG4FsL14tqLoEfqz9oRYuGru8rwMvOhH2vs7UPPg';\n  const query = {\n    'entry.979040326': values.data1, // 傳送使用者在表單填寫的資訊\n    'entry.589442071': values.data2,\n  };\n\n  uploadToGoogleSheet(FORM_ID, query)\n    .then(() =&gt; {\n      // 提交成功後的處理\n      console.log('數據成功提交到Google表單');\n    })\n    .catch(() =&gt; {\n      // 提交失敗後的處理\n      console.error('提交數據到Google表單時出錯');\n    });\n};\n\n\n程式碼其實相當簡單，我們只需要將剛剛拿到的form ID帶進URL中，再將各欄位的entry ID帶入查詢字串中當作鍵，值則給予使用者在客製化表單上輸入的值，POST請求成功後回到Google Sheet就會看到剛剛提交的值已經被記錄下來囉！\n\n小結\n雖然說這是一個沒什麼技術含量的分享，但我認為這樣的方式十分有趣，以某些使用情境來說也是非常適合的一種記錄表單資料的方式，Google表單雖然方便，但有時候總會因為缺乏「美感」或是獨立於我們網頁之外而使人卻步，如果你有類似的問題，不妨試試看本篇文章教的方法吧，希望這篇文章能夠幫助到螢幕前的你！\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2018-08-05-blog-google-sheet/"
    },{
      "image": "https://img.technews.tw/wp-content/uploads/2017/12/29164436/browsers-1265309_1280.png",
      "title": "現代瀏覽器架構與渲染機制",
      "date": "2018-10-10 00:00:00 +0800",
      
      "content": "\n  單一程序瀏覽器時期    \n      問題\n    \n  \n  進化：多程序瀏覽器時期    \n      改進\n    \n  \n  現代瀏覽器架構    \n      優勢\n    \n  \n  SOA 瀏覽器架構    \n      彈性架構\n    \n  \n  瀏覽器渲染機制    \n      渲染流程\n      Layer 分層與 Compositing\n    \n  \n  結語    \n      References\n    \n  \n\n\n\n  「瀏覽器的進步使得我們能在網頁上實現越來越多的功能。」\n\n\n作為 Web 工程師，尤其是前端開發者，了解瀏覽器的架構和渲染機制是非常重要的。這篇文章將帶你從瀏覽器的單一程序架構到多程序架構，再到現代的多層次架構，深入了解瀏覽器的演進過程。\n\n單一程序瀏覽器時期\n早期在2007年之前瀏覽器基本上都是單一程序架構。所有功能模組都運行在同一個程序中，這導致了不穩定性、不流暢性和安全性問題。\n\n\n\n問題\n\n  不穩定性：一個模組出問題會導致整個瀏覽器崩潰。\n  不流暢性：單一執行緒導致資源被獨佔，影響整體性能。\n  安全性問題：缺乏沙盒機制，容易被惡意程式攻擊。\n\n\n進化：多程序瀏覽器時期\n2008 年，Chrome 推出了多程序架構，將渲染程序和插件程序獨立出來，通過 IPC 進行溝通。\n\n\n\n改進\n\n  穩定性：各個程序互相隔離，單一模組崩潰不會影響整體。\n  流暢性：每個 Tab 獨立運行在不同的渲染程序中，提升了性能。\n  安全性：引入沙盒機制，提升了安全性。\n\n\n現代瀏覽器架構\n現代瀏覽器進一步將網路資源操作和 GPU 操作獨立出來，形成更加豐富的多程序架構。\n\n\n\n優勢\n\n  性能提升：多程序並行運行，提升了整體性能。\n  更高的穩定性和安全性：進一步隔離不同功能模組，提升了穩定性和安全性。\n\n\nSOA 瀏覽器架構\nChrome 團隊提出了以 SOA 為基礎的新架構，將各個功能模組作為服務運行，實現高內聚、低耦合、易擴展與易維護的特性。\n\n\n\n彈性架構\n\n  高性能設備：拆分成多個程序運行，提升穩定性和效能。\n  低性能設備：合併成單一程序運行，節省記憶體。\n\n\n瀏覽器渲染機制\n現代瀏覽器的渲染機制包括 DOM Tree、CSSOM Tree、Render Tree、Layout Tree 和 Paint 階段。\n\n\n\n渲染流程\n\n  生成 DOM Tree\n  生成 CSSOM Tree\n  生成 Render Tree\n  生成 Layout Tree\n  Paint 畫面\n\n\nLayer 分層與 Compositing\n瀏覽器會根據 Layout Tree 產生 Layer Tree，並在 Compositor Thread 進行合成，提升渲染效能。\n\n\n\n結語\n瀏覽器的進步使得我們能在網頁上實現越來越多的功能。作為 Web 開發者，了解瀏覽器的架構和渲染機制，能夠幫助我們更好地開發高效能的網頁應用。\n\nReferences\n\n  Inside look at modern web browser (Part 1, 2, 3, 4)\n  浏览器工作原理与实践\n  Chrome Site Isolation\n  Rendering Performance\n  Reflow 和 Repaint 引發的性能問題\n  DOM Performance\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2018-10-10-blog-browser/"
    },{
      "image": "https://chilli.codes/wp-content/uploads/2020/10/git.jpg",
      "title": "Git – repository 遠端操作出現 「Please make sure you have the correct access rights...SSH或權限錯誤 - GitHub",
      "date": "2018-11-20 00:00:00 +0800",
      
      "content": "\n  方法一： 取消與remote連接，重新連接後，並設定識別資料\n  方法二： 更換與遠短連接方式，重新請求設定 username 與 password\n\n\n\n  之前因為自己公司筆電跟自家桌機常常需要切換開發，導致我自己的個人部落格在不同電腦上要進行同步，或是在接手專案要維護的時候，準備要 git pull 卻出現錯誤。去google網路看是不是SSH的問題，但查了又不是此類的問題，如果你也剛好遇到此問題可以來試試以下這段：\n\n\n$ git push origin master\n\nERROR: Repository not found.\nfatal: Could not read from remote repository.\n\n--------------\n\nPlease make sure you have the correct access rights\nand the repository exists.\n \nERROR: Repository not found.\nfatal: Could not read from remote repository.\n\n\n\n上google了解是因為使用 ssh 連線到 GitHub 但可能出現 key 導致錯誤發生，不想再替換SSH或重新安裝的人，可以重新設定識別資料或是設置password來解決這個困擾。\n\n方法一： 取消與remote連接，重新連接後，並設定識別資料\n\n\n\n$ git remote add origin git@gitlab.com:XXX\n$ git config --global user.name \"John Doe\"\n$ git config --global user.email johndoe@example.com\n\n\n方法二： 更換與遠短連接方式，重新請求設定 username 與 password\n\n# 先確定目前remote連結\n$ git remote -v\n \n# 若如果出現這樣，可發現之前用的是走 https 通道\norigin\thttps://github.com/{username}/{repo}.git (fetch)\norigin\thttps://github.com/{username}/{repo}.git (push)\n \n# 接著試試(應該是不會給過)\n$ git remote add origin git@github.com:{username}/{repo}.git\n \n# 然後會說已經存在\nfatal: remote origin already exists.\n \n# 接著設定 set-url 修改為走模式 SSH 連線方式\n$ git remote set-url origin https://github.com/{username}/{repo}.git\n \n# 確認一下\ngit remote -v\n \n# 代表成功替換\n$ origin\tgit@github.com:{username}/{repo}.git (fetch)\n$ origin\tgit@github.com:{username}/{repo}.git (push)\n \n# 然後將專案 pull \n$ git pull\n \n# 伺服器就會詢問 GitHub 帳號密碼了\nUsername for 'https://github.com': \nPassword for 'https://github.com': \n\n\n\n參考來源\n\n1.6 開始 - 初次設定 Git https://git-scm.com/ \nGit – GitHub 出現 http://jsnwork.kiiuo.com/\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2018-11-20-blog-git/"
    },{
      "image": "https://miro.medium.com/max/2000/1*TnGnN4mSbfcvVczYYh2m7g.png",
      "title": "Git - 如何在現有的專案中建立子repository模塊， submodule 使用教學 - GitHub",
      "date": "2018-12-19 00:00:00 +0800",
      
      "content": "\n  何謂 Git Submodule\n  先在 GitHub 建立好 子Repository，然後在主專案輸入指令    \n      建議不先預留資料夾否則會無法建立\n    \n  \n  子Repository Clone 完成    \n      如果你有多個子專案，請務必注意，此文件與你的其他文件（例如你的.gitignore文件）一起受版本控制。它與項目的其餘部分一起更新或取回。\n    \n  \n  Reference\n\n\n\n  主要會使用到 Git Submodule 是因為部落格是使用 GitHub Pages，是GitHub提供的一個網頁代管服務，其中 Jekyll 軟體可以用於將文檔轉換成靜態網頁，該軟體提供了將網頁上傳到GitHub Pages的功能可說是超級方便！\n\n\n何謂 Git Submodule\n簡單的來講，就是巢狀的 Git 結構，意思是主專案中又有一個子專案需要拆開來使用git，類似一種 Library 套件管理的概念，像是大家在開發新專案的時候，如果想要用到其他專案的程式碼時，像是主流的 CSS Framwork 如：Vuetify、Bootstrap、Element UI，這些大型套件都放在 Github 方便進行維護更新，從前的作法就是先 git clone 下來，把要的檔案分別複製到自己專案，但是這樣麻煩的問題就來了！\n若不是用 npm 或 webpack 這種套件管理，假如官方有釋出新版本，那要如何更新呢？這時可別再下載zip手動更新了，這時候 Git Submodule 就是一個不錯的解決方案，幫助大家方便管理程式碼！\n\n先在 GitHub 建立好 子Repository，然後在主專案輸入指令\n\n正常來說當你有一個 Repository，裡面如果包有一個子 Repository的話。是不能用 Git Push 推送到 remote repository裡的，這可能會發生問題，因此這邊就要加入 Git Submodule 的指令操作。\n\n讓我們首先在遠端建立好欲添加的子Repository。並複製http或SSH連結，在主專案裡輸入git submodule add來開起追蹤命令，在此示範建立子專案”subCase”：\n\n建議不先預留資料夾否則會無法建立\n\n$ git submodule add {子專案的repo.git} {選填：主專案中欲儲存的子資料夾之資料夾名稱}\n\nCloning into 'subCase'...\nremote: Counting objects: 11, done.\nremote: Compressing objects: 100% (10/10), done.\nremote: Total 11 (delta 0), reused 11 (delta 0)\nUnpacking objects: 100% (11/11), done.\nChecking connectivity... done.\n\n\n在默認地情況下，子專案會將子項目添加到與Repository同名的目錄中，在本例中為“subCase”。所以如果你希望它建立在其他資料夾，你可以在命令的末尾添加想要的資料夾名稱。\n\n子Repository Clone 完成\nReactivating local git directory for submodule 'subCase'.\nwarning: LF will be replaced by CRLF in .gitmodules.\nThe file will have its original line endings in your working directory\n\n\n如果你此時運行git status，你會注意到一些事情。\n\n$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\n\nChanges to be committed:\n  (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n\tnew file:   .gitmodules\n\tnew file:   subCase\n\n\n然後在主專案的.git資料夾裡，可以注意到新.gitmodules文件的配置文件，為用於存儲項目 URL 和你將其拉入的本地子目錄之間的映射：\n\n[submodule \"subCase\"]\n\tpath = subCase\n\turl = https://github.com/test/subCase\n\n\n如果你有多個子專案，請務必注意，此文件與你的其他文件（例如你的.gitignore文件）一起受版本控制。它與項目的其餘部分一起更新或取回。\n\nReference\nhttps://git-scm.com/docs/git-submodule\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2018-12-19-blog-submodule/"
    },{
      "image": "https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif",
      "title": "JS - 氣泡排序法 O(n²) Bubble Sort - 資料結構演算法",
      "date": "2019-01-14 00:00:00 +0800",
      
      "content": "\n  初學者入門學習的演算法 - 泡沫排序 Bubble Sort\n  如果相鄰元素的順序錯誤，則冒泡排序算法會重複交換相鄰元素\n  Reference\n\n\n初學者入門學習的演算法 - 泡沫排序 Bubble Sort\n\n泡沫排序演算法的運作如下：\n\n比較相鄰的元素。如果第一個比第二個大，就交換他們兩個。\n對每一對相鄰元素作同樣的工作，從開始第一對到結尾的最後一對。這步做完後，最後的元素會是最大的數。\n針對所有的元素重複以上的步驟，除了最後一個。\n持續每次對越來越少的元素重複上面的步驟，直到沒有任何一對數字需要比較。\n由於它的簡潔，泡沫排序通常被用來對於程式設計入門的學生介紹演算法的概念。\n\n如果相鄰元素的順序錯誤，則冒泡排序算法會重複交換相鄰元素\n\n冒泡排序常用於實現排序算法。氣泡中的每個元素都與其周圍的元素形成對比。以泡泡形式。該列表將通過算法進行處理。對具有 n 個元素的列表進行排序需要 N-1 遍。取一個包含 n 個元素的表 A，這些元素必須用某種氣泡排序。算法如下\n• 在第 1 輪中，數字 A[0] 由 A[1] 組成，數字 A[1] 與 A[2] 進行比較，數字 A[2] 與 A[3] 進行比較，等等. 列表中最大的項放在第 1 輪的末尾，位於列表的最高索引處。\n• A[0] 與第 2 輪中的 A[1] 進行比較，A[1] 與 A[2] 進行比較，依此類推。第二大項放在列表末尾的第二高索引上通過 2。\n• 第 n-1 次移動將 A[0] 與 A[1]、A[1] 與 A[2] 進行比較，依此類推。傳球在底部結束。列表的第一個索引是列表中最小的項目。\n\nvar n = [282, 6, 88, 44, 33, 12, 15, 121, 351, 234, 99];\nfor (m = 0; m &lt; 10; m++) {\n    for (j = 0; j &lt; 10; j++) {\n        if (n[m] &lt; n[j]) {\n            temp = n[m];\n            n[m] = n[j];\n            n[j] = temp;\n        }\n    }\n}\nhint = \"&lt;br&gt;\";\ndocument.writeln(\"數列經泡沫排序後 ..\" + hint);\nfor (m = 0; m &lt; 10; m++) {\n    document.writeln(n[m]);\n    document.writeln(hint);\n}\n\n\n\n\n\nReference\nhttps://laptrinhx.com/\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2019-01-14-blog-bubble/"
    },{
      "image": "https://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif",
      "title": "JS - 合併排序法 O(n logn) Merge Sort - 資料結構演算法",
      "date": "2019-01-22 00:00:00 +0800",
      
      "content": "\n  初學者入門學習的演算法 - 合併排序法 Merge Sort\n  理解歸併排序背後的邏輯\n  Reference\n\n\n初學者入門學習的演算法 - 合併排序法 Merge Sort\n\n排序是指按特定順序（數字或字母順序）排列列表中的項目。排序通常與搜索一起使用。\n如果在視覺上和算法上對列表進行了排序，那麼在給定列表中搜索元素（稱為key值）通常會更容易。\n有很多方法（算法）可以對給定的元素列表進行排序。歸併排序是一種更流行、更有效的方法。\n\n理解歸併排序背後的邏輯\n合併排序使用分而治之的概念對給定的元素列表進行排序。它將問題分解為更小的子問題，直到它們變得簡單到可以直接解決。\n\n以下是歸併排序的步驟：\n\n將給定的列表分成兩半（對於具有奇數個元素的列表，大致相等的一半）。\n繼續以相同的方式劃分子數組，直到只剩下單個元素數組。\n從單元素數組開始，合併子數組，以便對每個合併的子數組進行排序。\n重複第 3 步，最終得到一個排序數組。\n\n\n\n\nfunction merge(left, right) {\n    let arr = []\n    // Break out of loop if any one of the array gets empty\n    while (left.length &amp;&amp; right.length) {\n        // Pick the smaller among the smallest element of left and right sub arrays\n        if (left[0] &lt; right[0]) {\n            arr.push(left.shift())  \n        } else {\n            arr.push(right.shift()) \n        }\n    }\n    \n    // Concatenating the leftover elements\n    // (in case we didn't go through the entire left or right array)\n    return [ ...arr, ...left, ...right ]\n}\n\nfunction mergeSort(array) {\n  const half = array.length / 2\n  \n  // Base case or terminating case\n  if(array.length &lt; 2){\n    return array \n  }\n  \n  const left = array.splice(0, half)\n  return merge(mergeSort(left),mergeSort(array))\n}\n\narray = [4, 8, 7, 2, 11, 1, 3];\nconsole.log(mergeSort(array));\n\n[1, 2, 3, 4, 7, 8, 11]\n\n\n\nReference\nhttps://stackabuse.com/merge-sort-in-javascript\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2019-01-22-blog-mergesort/"
    },{
      "image": "https://2.bp.blogspot.com/-EYBE6CHprjg/W4O3ZR-1uhI/AAAAAAAAz6E/iQ-1-NXU_hIbECnTSEnIXT19AX9HHocbACLcBGAs/s1600/Multiple%2BRepo.PNG",
      "title": "Git – git push 同時推送到多個遠端儲存庫",
      "date": "2021-11-27 00:00:00 +0800",
      
      "content": "\n  同一個Repositories如何設定兩組不同的遠端儲存庫    \n      如果你在工作目錄想同時保有兩個不同的遠端儲存庫，而且兩個遠端儲存庫你都有權限，都有可能會做 Push 或 Pull/Fetch 動作。\n    \n  \n  Reference\n\n\n同一個Repositories如何設定兩組不同的遠端儲存庫\n如果你在工作目錄想同時保有兩個不同的遠端儲存庫，而且兩個遠端儲存庫你都有權限，都有可能會做 Push 或 Pull/Fetch 動作。\n\n那麼我們本地開發目錄的設定步驟如下：\n\n取得原始碼 (取出 develop 分支)\n\ngit clone https://github.com/XXX.git -b develop\ncd demo1\n\n設定第二組遠端儲存庫位址\n\ngit remote add demo2 https://github.com/XXX-2.git\n\n如果第二組遠端儲存庫位址是 origin 的 上游專案(upstream)，我們有時候會直接設定 Remote 名稱為 upstream，如此一來語意就會非常清楚。\n\n檢查 Git Remote 位址\n\n此時你應該會看見兩組 Remote 位址，個別都有 fetch 與 push 位址：\n\n# git remote -v\norigin  https://github.com/XXX.git (fetch)\norigin  https://github.com/XXX.git (push)\ndemo2  https://github.com/XXX-2.git (fetch)\ndemo2  https://github.com/XXX-2.git (push)\n\n\n當你想取回 origin 的新版本時，使用 git pull 或 git fetch 就可以取得。\n\n當你想取回 demo2 的新版本時，使用 git pull demo2 或 git fetch demo2 就可以取回新版。\n\n當你想取回所有 Remote 的新版本時，就不能用 git pull 命令了，因為 Git 不會知道你想合併哪一條遠端分支。你只能用 git fetch –all 取回所有新的版本(Commits)，但你就要自行決定如何合併遠端的版本變更了！\n\nReference\nhttps://blog.miniasp.com/\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2021-11-27-blog-git-remote/"
    },{
      "image": "https://alexmanrique.com/blog/images/jekyll_m1.jpg",
      "title": "jekyll – 如何在 Apple M1 Macbook 上安裝 jekyll",
      "date": "2022-03-05 00:00:00 +0800",
      
      "content": "\n  因為剛好最近買了一台 M1 imac，剛好需要重新安裝 Jekyll 寫BLOG，因為無法順利安裝的坑，真心覺得 M1 架構上處理環境真的不是那麼簡單。如果你也剛好遇到，此篇可以讓你解決M1 Mac 安裝 Jekyll的問題…    \n      目前 iMac 的作業環境為 Monterey ios 12.4：        \n          首先需要先安裝套件管理工具：\n          再來安裝 Rbenv\n          安裝基於 ARM 的 Ruby 3.0.0\n          將 ruby​​ 和 gems 路徑添加到您的 shell 配置中\n        \n      \n    \n  \n  安裝 Jekyll    \n      如果您使用的是 zsh\n      如果您使用的是 bash\n      更新套件(非必要)\n      檢查安裝\n      如果您還沒有進行本地安裝\n      如果您沒有blog，請使用\n    \n  \n  終於可以運行啦！！\n  Reference\n\n\n因為剛好最近買了一台 M1 imac，剛好需要重新安裝 Jekyll 寫BLOG，因為無法順利安裝的坑，真心覺得 M1 架構上處理環境真的不是那麼簡單。如果你也剛好遇到，此篇可以讓你解決M1 Mac 安裝 Jekyll的問題…\n\n目前 iMac 的作業環境為 Monterey ios 12.4：\n\n首先需要先安裝套件管理工具：\n我使用 Homebrew 在我的 Mac 上安裝第三方軟件包。可以通過簡單的方式安裝：\n\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n\n再來安裝 Rbenv\n我們需要安裝一個兼容 ARM 處理器的 Ruby 版本。\nbrew install rbenv ruby-build\n\n\n安裝基於 ARM 的 Ruby 3.0.0\n\nrbenv install 3.0.0\nrbenv global 3.0.0\nruby -v\nrbenv rehash\n\n\n將 ruby​​ 和 gems 路徑添加到您的 shell 配置中\n現在，將 rbenv 添加到 bash 以便每次打開終端時加載它\n\n如果您使用的是 zsh\necho 'eval \"$(rbenv init - zsh)\"' &gt;&gt; ~/.zshrc\n\n\n如果您使用的是 bash\necho 'eval \"$(rbenv init - bash)\"' &gt;&gt; ~/.bash_profile\n\n\n如果您不確定您使用的是哪個 shell，您可以使用以下命令進行檢查：\n\necho $SHELL\n\n\n安裝 Jekyll\n最後，我們可以繼續安裝 Jekyll 和 Bundler。我們將進行本地安裝（不需要sudo特權）。\n\ngem install --user-install bundler jekyll\n\n\n如果您使用的是 zsh\n替換3.0.0為您的 ruby​​ 版本。您可以通過 . 檢查您的 ruby​​ 版本ruby -v。如果您的 ruby​​ 版本是 2.7，則使用2.7.0.\n\necho 'export PATH=\"/usr/local/opt/ruby/bin:/usr/local/lib/ruby/gems/3.0.0/bin:$PATH\"' &gt;&gt; ~/.zshrc\n\n\n如果您使用的是 bash\n替換3.0.0為您的 ruby​​ 版本。您可以通過 . 檢查您的 ruby​​ 版本ruby -v。如果您的 ruby​​ 版本是 2.7，則使用2.7.0.\n\necho 'export PATH=\"/usr/local/opt/ruby/bin:/usr/local/lib/ruby/gems/3.0.0/bin:$PATH\"' &gt;&gt; ~/.bash_profile\n\n\n更新套件(非必要)\n對於 M1 Mac，我們可能需要做一些額外的步驟——更新 bundler、添加 webrick 並重建所有內容。\n\nbundle update --bundler\nbundle add webrick\nbundle install --redownload\n\n\n檢查安裝\n現在，我們可以運行我們的示例blog。導航到您的blog，然後運行以下命令：\n\n如果您還沒有進行本地安裝\ngem install bundler jekyll \n\n\n如果您沒有blog，請使用\njekyll new my-awesome-site\ncd my-awesome-site\n\n\n終於可以運行啦！！\n接下來應該就大功告成了，開始寫blog吧～\n\nbundle exec jekyll serve\n\n\nReference\nhttps://talk.jekyllrb.com/t/jekyll-crashing-on-m1-mac/6367/16\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2022-03-05-blog-jekyll-M1/"
    },{
      "image": "https://vuejs.org/images/logo.png",
      "title": "Vue 2 vs Vue 3 主要差異與升級建議",
      "date": "2022-03-14 00:00:00 +0800",
      
      "content": "\n  前言\n  主要差異    \n      1. API風格\n      2. 性能\n      3. TypeScript支持\n      4. 組件結構\n      5. 新特性\n    \n  \n  升級建議\n  總結\n  參考資料\n\n\n前言\n\nVue 3的發布為Vue開發者帶來了許多新特性和改進。本文將對比Vue 2和Vue 3的主要差異,並提供一些升級建議。\n\n主要差異\n\n1. API風格\n\n\n  Vue 2: 主要使用Options API\n  Vue 3: 引入Composition API,同時保留Options API\n\n\nComposition API提供了更靈活的代碼組織方式,特別適合大型項目。\n\n2. 性能\n\n\n  Vue 2: 性能已經很好\n  Vue 3: 顯著提升,包括更快的虛擬DOM、更高效的組件初始化等\n\n\n3. TypeScript支持\n\n\n  Vue 2: 有限的TypeScript支持\n  Vue 3: 全面改進的TypeScript支持,包括更準確的類型推斷\n\n\n4. 組件結構\n\n\n  Vue 2: 單根節點組件\n  Vue 3: 支持多根節點組件\n\n\n5. 新特性\n\nVue 3引入了一些新特性,如:\n\n  Teleport組件\n  Fragments\n  Suspense\n  更好的響應式系統\n\n\n升級建議\n\n\n  評估項目需求: 對於小型項目,可能暫時不需要升級\n  學習Composition API: 即使不立即升級,也建議學習這一新特性\n  逐步遷移: 可以使用Vue 3的兼容版本,逐步更新代碼\n  利用新工具: 使用Vite等新工具提高開發效率\n\n\n總結\n\nVue 3帶來了許多改進,但Vue 2仍然是一個穩定可靠的選擇。根據項目需求和團隊情況,選擇合適的版本進行開發。\n\n參考資料\n\n  Vue 3 官方文檔\n  Vue 2 到 Vue 3 遷移指南\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2022-03-14-blog-vue2vsVue3-1/"
    },{
      "image": "https://vuejs.org/images/logo.png",
      "title": "Vue 2 vs Vue 3 深入技術比較與開發實踐",
      "date": "2022-04-07 00:00:00 +0800",
      
      "content": "\n  引言\n  核心架構變化    \n      1. 響應式系統\n      2. 虛擬DOM算法\n    \n  \n  開發體驗改進    \n      1. Composition API vs Options API\n      2. 生命週期鉤子\n      3. 異步組件\n    \n  \n  性能優化    \n      1. 樹搖優化\n      2. 編譯優化\n    \n  \n  新特性深入解析    \n      1. Teleport\n      2. Fragments\n      3. Suspense\n    \n  \n  遷移策略\n  結論\n  參考資料\n\n\n引言\n\nVue 3的發布不僅帶來了新特性,還對框架的核心進行了重寫。本文將深入探討Vue 2和Vue 3在技術實現和開發實踐上的差異。\n\n核心架構變化\n\n1. 響應式系統\n\n\n  Vue 2: 基於Object.defineProperty實現\n  Vue 3: 採用Proxy實現\n\n\n影響:\n\n  性能提升: Proxy可以攔截更多操作,如新增屬性\n  更好的數組變更檢測\n  大型應用中的內存占用減少\n\n\n2. 虛擬DOM算法\n\n\n  Vue 2: 基於snabbdom\n  Vue 3: 重寫的虛擬DOM算法\n\n\n優化:\n\n  靜態樹提升\n  靜態屬性提升\n  基於Proxy的響應式追踪\n\n\n開發體驗改進\n\n1. Composition API vs Options API\n\n詳細比較:\n\n\n  \n    \n      特性\n      Options API\n      Composition API\n    \n  \n  \n    \n      代碼組織\n      按選項類型\n      按邏輯功能\n    \n    \n      可重用性\n      主要通過mixins\n      更靈活的組合式函數\n    \n    \n      TypeScript支持\n      有限\n      優秀\n    \n    \n      代碼壓縮\n      較差\n      更好\n    \n  \n\n\n2. 生命週期鉤子\n\nVue 3中的變化:\n\n  beforeCreate和created被setup()替代\n  其他鉤子前綴改為on (如onMounted)\n\n\n3. 異步組件\n\n\n  Vue 2: 需要特定的導入語法\n  Vue 3: 內置defineAsyncComponent輔助函數\n\n\n性能優化\n\n1. 樹搖優化\n\nVue 3實現了更好的樹搖,未使用的API不會被打包。\n\n2. 編譯優化\n\nVue 3引入了基於塊的編譯策略,顯著提高了渲染性能。\n\n新特性深入解析\n\n1. Teleport\n\n使用場景:\n\n  模態框\n  懸浮提示\n  全局通知\n\n\n2. Fragments\n\n多根節點組件的實際應用:\n\n  列表渲染優化\n  更靈活的組件結構\n\n\n3. Suspense\n\n與異步組件結合使用,優化加載體驗。\n\n遷移策略\n\n\n  漸進式遷移:\n    \n      使用@vue/compat\n      逐步替換全局API\n      更新組件語法\n    \n  \n  重構建議:\n    \n      優先考慮核心組件\n      利用新特性重寫複雜邏輯\n      引入TypeScript增強代碼質量\n    \n  \n\n\n結論\n\nVue 3在保持Vue 2優點的同時,在性能、TypeScript支持和開發體驗上有了顯著提升。對於新項目,強烈建議使用Vue 3;對於現有項目,則需要權衡遷移成本和收益。\n\n參考資料\n\n\n  Vue 3 設計理念\n  Vue RFCs\n  Vue 3 遷移指南\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2022-04-07-blog-vue2vsVue3-2/"
    },{
      "image": "https://vuejs.org/images/logo.png",
      "title": "Vue 3 使用心得與秘訣分享",
      "date": "2022-06-08 00:00:00 +0800",
      
      "content": "\n  前言    \n      Composition API: 更靈活的代碼組織方式\n      更快的性能\n      Teleport組件: 靈活控制DOM結構\n      多根節點組件\n      更好的TypeScript支持\n    \n  \n  總結\n  參考資料\n\n\n前言\n\n最近我開始使用Vue 3進行開發,發現它相比Vue 2有許多令人興奮的新特性。在這篇文章中,我想分享一些我使用Vue 3的心得與秘訣,希望能對你有所幫助。\n\nComposition API: 更靈活的代碼組織方式\n\nVue 3最大的變化之一就是引入了Composition API。這為我們提供了一種新的方式來組織組件邏輯。以下是我的一些使用心得:\n\n\n  將相關的邏輯集中在一起,提高了代碼的可讀性。\n  更容易重用邏輯,可以將常用功能抽取成獨立的組合式函數。\n  對TypeScript的支持更好,類型推斷更準確。\n\n\nimport { ref, computed, onMounted } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    const doubleCount = computed(() =&gt; count.value * 2)\n    \n    function increment() {\n      count.value++\n    }\n    \n    onMounted(() =&gt; {\n      console.log('組件已掛載')\n    })\n\n    return {\n      count,\n      doubleCount,\n      increment\n    }\n  }\n}\n\n\n更快的性能\n\nVue 3在性能方面有了顯著提升,這讓我在開發大型應用時感受明顯:\n\n\n  虛擬DOM重寫,渲染速度更快。\n  更高效的組件初始化。\n  更好的Tree-shaking支持,打包體積更小。\n\n\nTeleport組件: 靈活控制DOM結構\n\nTeleport組件讓我可以將子組件渲染到DOM樹的任何位置,這在處理模態框、彈出提示等場景非常有用:\n\n//html\n&lt;teleport to=\"body\"&gt;\n&lt;div class=\"modal\"&gt;\n&lt;!-- 模態框內容 --&gt;\n&lt;/div&gt;\n&lt;/teleport&gt;\n\n\n多根節點組件\n\nVue 3允許組件模板有多個根節點,這讓模板結構更加靈活:\n\n//html\n&lt;template&gt;\n&lt;header&gt;...&lt;/header&gt;\n&lt;main&gt;...&lt;/main&gt;\n&lt;footer&gt;...&lt;/footer&gt;\n&lt;/template&gt;\n\n\n更好的TypeScript支持\n\n作為一個TypeScript愛好者,我非常喜歡Vue 3對TypeScript的改進:\n\n\n  更準確的類型推斷。\n  更好的IDE支持,代碼提示更智能。\n  可以為props、emits等選項提供類型定義。\n\n\n總結\n\nVue 3為我們帶來了許多激動人心的新特性,讓開發體驗更加愉悅。雖然學習新的API需要一些時間,但我認為這絕對值得。如果你還沒有嘗試Vue 3,我強烈建議你開始使用它,相信你會和我一樣愛上它的!\n\n參考資料\n\n  Vue 3 官方文檔\n  Vue 3 Composition API\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2022-06-08-blog-vue3-1/"
    },{
      "image": "https://vuejs.org/images/logo.png",
      "title": "Vue 3 進階技巧與最佳實踐",
      "date": "2022-06-25 00:00:00 +0800",
      
      "content": "\n  前言\n  響應式系統的深入理解    \n      ref vs. reactive\n      toRef 和 toRefs\n    \n  \n  組合式函數(Composables)\n  異步組件和懶加載\n  自定義指令的新寫法\n  更好的TypeScript集成\n  總結\n  參考資料\n\n\n前言\n\n在上一篇文章中,我們介紹了Vue 3的基本特性和使用心得。這次,我們將深入探討一些Vue 3的進階技巧和最佳實踐,幫助你更好地利用Vue 3的強大功能。\n\n響應式系統的深入理解\n\nref vs. reactive\n\n在Vue 3中,我們有兩種主要的方式來創建響應式數據:ref和reactive。讓我們深入了解它們的區別和使用場景:\n\n\n  ref適用於基本類型數據,reactive適用於對象類型數據。\n  ref需要通過.value訪問,而reactive可以直接訪問屬性。\n  ref在模板中使用時會自動解包。\n\n\nimport { ref, reactive } from 'vue'\n\nconst count = ref(0)\nconst state = reactive({ name: 'Vue 3', version: 3 })\n\n// 使用\nconsole.log(count.value) // 0\nconsole.log(state.name) // 'Vue 3'\n\n\ntoRef 和 toRefs\n\n這兩個工具函數可以幫助我們在不丟失響應性的情況下解構reactive對象:\n\nimport { reactive, toRef, toRefs } from 'vue'\n\nconst state = reactive({ count: 0, name: 'Vue' })\n\n// 單個屬性\nconst count = toRef(state, 'count')\n\n// 多個屬性\nconst { count, name } = toRefs(state)\n\n\n組合式函數(Composables)\n\n組合式函數是Vue 3中重用邏輯的主要方式。以下是一些最佳實踐:\n\n\n  使用use前綴命名組合式函數。\n  返回一個包含響應式數據和方法的對象。\n  在setup函數中調用組合式函數。\n\n\n// useCounter.js\nimport { ref } from 'vue'\n\nexport function useCounter(initialValue = 0) {\n  const count = ref(initialValue)\n  \n  function increment() {\n    count.value++\n  }\n  \n  return { count, increment }\n}\n\n// 使用\nimport { useCounter } from './useCounter'\n\nexport default {\n  setup() {\n    const { count, increment } = useCounter(10)\n    return { count, increment }\n  }\n}\n\n\n異步組件和懶加載\n\nVue 3提供了更簡單的方式來定義異步組件,這對於大型應用的性能優化非常有用:\n\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComponent = defineAsyncComponent(() =&gt;\n  import('./components/AsyncComponent.vue')\n)\n\n\n自定義指令的新寫法\n\nVue 3中自定義指令的API有所變化,更接近組件的生命週期:\n\nconst myDirective = {\n  mounted(el, binding) {\n    // 元素被插入到DOM時\n  },\n  updated(el, binding) {\n    // 元素更新時\n  }\n}\n\n// 使用\napp.directive('my-directive', myDirective)\n\n\n更好的TypeScript集成\n\nVue 3對TypeScript的支持更加友好。以下是一些技巧:\n\n\n  使用defineComponent來獲得更好的類型推斷。\n  為props和emits定義類型。\n  使用泛型來增強組合式函數的類型安全。\n\n\nimport { defineComponent, PropType } from 'vue'\n\ninterface User {\n  name: string\n  age: number\n}\n\nexport default defineComponent({\n  props: {\n    user: {\n      type: Object as PropType&lt;User&gt;,\n      required: true\n    }\n  },\n  emits: {\n    'update': (value: string) =&gt; true\n  },\n  setup(props, { emit }) {\n    // ...\n  }\n})\n\n\n總結\n\nVue 3為我們提供了許多強大的工具和API,讓我們能夠構建更加靈活、高效的應用。通過深入理解這些進階技巧,我們可以充分發揮Vue 3的潛力,寫出更加優雅和可維護的代碼。\n\n希望這些技巧能夠幫助你在Vue 3的開發之路上走得更遠!\n\n參考資料\n\n  Vue 3 組合式API指南\n  Vue 3 TypeScript支持\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2022-06-25-blog-vue3-2/"
    },{
      "image": "https://media.licdn.com/dms/image/D5612AQG28-Q25BRGDA/article-cover_image-shrink_720_1280/0/1715091435390?e=2147483647&v=beta&t=a-ooQtZ5J4DThRJvSJpQjPG9x5czjYkUtGnwNfzeKRE",
      "title": "Vue 3 與 React 16.8 基本技術比較",
      "date": "2022-07-02 00:00:00 +0800",
      
      "content": "\n  前言\n  組件定義    \n      Vue 3\n      React 16.8\n    \n  \n  響應式系統    \n      Vue 3\n      React 16.8\n    \n  \n  生命週期    \n      Vue 3\n      React 16.8\n    \n  \n  條件渲染    \n      Vue 3\n      React 16.8\n    \n  \n  列表渲染    \n      Vue 3\n      React 16.8\n    \n  \n  總結\n  參考資料\n\n\n前言\n\nVue 3和React 16.8都是在2020年前後推出的重要版本,它們都引入了新的特性來改善開發體驗。本文將從幾個關鍵方面比較Vue 3和React 16.8的基本技術,幫助開發者更好地理解這兩個框架的異同。\n\n組件定義\n\nVue 3\n\nVue 3引入了組合式API,同時保留了選項式API:\n\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    const increment = () =&gt; {\n      count.value++\n    }\n    return { count, increment }\n  }\n}\n\n\nReact 16.8\n\nReact 16.8引入了Hooks,使函數組件能夠使用狀態和其他React特性:\n\nimport React, { useState } from 'react'\n\nfunction Counter() {\n  const [count, setCount] = useState(0)\n  \n  const increment = () =&gt; {\n    setCount(count + 1)\n  }\n  \n  return (\n    &lt;div&gt;\n      &lt;p&gt;{count}&lt;/p&gt;\n      &lt;button onClick={increment}&gt;增加&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n\n\n響應式系統\n\nVue 3\n\nVue 3使用Proxy實現響應式系統,提供了ref和reactive兩個主要API:\n\nimport { ref, reactive } from 'vue'\n\nconst count = ref(0)\nconst state = reactive({ name: 'Vue' })\n\n\nReact 16.8\n\nReact 16.8通過useState和useReducer管理狀態:\n\nimport React, { useState } from 'react'\n\nfunction Example() {\n  const [count, setCount] = useState(0)\n  const [state, setState] = useState({ name: 'React' })\n}\n\n\n生命週期\n\nVue 3\n\nVue 3提供了一系列組合式API的生命週期鉤子:\n\nimport { onMounted, onUpdated, onUnmounted } from 'vue'\n\nexport default {\n  setup() {\n    onMounted(() =&gt; {\n      console.log('組件已掛載')\n    })\n    onUpdated(() =&gt; {\n      console.log('組件已更新')\n    })\n    onUnmounted(() =&gt; {\n      console.log('組件已卸載')\n    })\n  }\n}\n\n\nReact 16.8\n\nReact 16.8使用useEffect Hook模擬生命週期:\n\nimport React, { useEffect } from 'react'\n\nfunction Example() {\n  useEffect(() =&gt; {\n    console.log('組件已掛載')\n    return () =&gt; {\n      console.log('組件將卸載')\n    }\n  }, [])\n  \n  useEffect(() =&gt; {\n    console.log('組件已更新')\n  })\n}\n\n\n條件渲染\n\nVue 3\n\n&lt;template&gt;\n  &lt;div v-if=\"show\"&gt;顯示內容&lt;/div&gt;\n  &lt;div v-else&gt;隱藏內容&lt;/div&gt;\n&lt;/template&gt;\n\n\nReact 16.8\n\nfunction Example({ show }) {\n  return (\n    &lt;&gt;\n      {show ? &lt;div&gt;顯示內容&lt;/div&gt; : &lt;div&gt;隱藏內容&lt;/div&gt;}\n    &lt;/&gt;\n  )\n}\n\n\n列表渲染\n\nVue 3\n\n&lt;template&gt;\n  &lt;ul&gt;\n    &lt;li v-for=\"item in items\" :key=\"item.id\"&gt;\n      \n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/template&gt;\n\n\nReact 16.8\n\nfunction List({ items }) {\n  return (\n    &lt;ul&gt;\n      {items.map(item =&gt; (\n        &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  )\n}\n\n\n總結\n\nVue 3和React 16.8都引入了重要的新特性,使得組件開發更加靈活和高效:\n\n\n  Vue 3引入組合式API,React 16.8引入Hooks,兩者都旨在提供更好的代碼組織和重用。\n  Vue 3的響應式系統更加直觀,而React 16.8的狀態管理需要顯式調用。\n  Vue 3保留了模板語法,React繼續使用JSX。\n  兩者都提供了類似的生命週期管理方式,但實現方式不同。\n\n\n選擇使用哪個框架取決於項目需求、團隊熟悉度和個人偏好。兩個框架都在不斷evolve,深入學習和實踐都能讓你成為出色的前端開發者。\n\n參考資料\n\n  Vue 3 官方文檔\n  React 16.8 官方文檔\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2022-07-02-blog-vue3&React/"
    },{
      "image": "https://media.licdn.com/dms/image/D5612AQG28-Q25BRGDA/article-cover_image-shrink_720_1280/0/1715091435390?e=2147483647&v=beta&t=a-ooQtZ5J4DThRJvSJpQjPG9x5czjYkUtGnwNfzeKRE",
      "title": "Vue 3 與 React 16.8 進階技術比較",
      "date": "2022-07-20 00:00:00 +0800",
      
      "content": "\n  前言\n  性能優化    \n      Vue 3\n      React 16.8\n    \n  \n  狀態管理    \n      Vue 3\n      React 16.8\n    \n  \n  代碼分割和懶加載    \n      Vue 3\n      React 16.8\n    \n  \n  服務端渲染 (SSR)    \n      Vue 3\n      React 16.8\n    \n  \n  總結\n  參考資料\n\n\n前言\n\nVue 3 和 React 16.8 都引入了革命性的新特性,大大提升了開發體驗和應用性能。本文將深入探討這兩個框架的進階特性,包括性能優化、狀態管理、代碼分割等方面,幫助開發者更全面地理解兩個框架的優勢和適用場景。\n\n性能優化\n\nVue 3\n\n\n  \n    靜態樹提升 (Static Tree Hoisting):\nVue 3 編譯器能夠檢測模板中的靜態內容,並將其提升到渲染函數之外,減少每次渲染時的計算量。\n  \n  \n    靜態屬性提升 (Static Props Hoisting):\n對於靜態的綁定,Vue 3 會在編譯時直接生成靜態的 VNode,避免運行時的開銷。\n  \n  \n    基於 Proxy 的響應式系統:\n相比 Vue 2 基於 Object.defineProperty 的實現,Vue 3 的 Proxy 實現提供了更好的性能和更少的限制。\n  \n\n\nReact 16.8\n\n\n  \n    並發模式 (Concurrent Mode):\nReact 16.8 引入了實驗性的並發模式,允許 React 中斷長時間運行的渲染,優先處理更高優先級的更新。\n  \n  \n    懶加載和 Suspense:\nReact.lazy() 和 Suspense 組件使得代碼分割和異步加載組件變得更加簡單。\n  \n  \n    記憶化 (Memoization):\nReact.memo 和 useMemo Hook 可以幫助避免不必要的重渲染,提高性能。\n  \n\n\n狀態管理\n\nVue 3\n\n\n  \n    Composition API:\n提供了更靈活的狀態管理方式,可以輕鬆地將邏輯抽取到可重用的函數中。\n  \n  \n    Provide/Inject:\n用於跨組件層級傳遞數據,類似於 React 的 Context API。\n  \n  \n    Vuex 4:\n專為 Vue 3 設計的狀態管理庫,支持 Composition API。\n  \n\n\nimport { provide, inject } from 'vue'\nimport { createStore } from 'vuex'\n\n// 在根組件中\nprovide('store', store)\n\n// 在子組件中\nconst store = inject('store')\n\n\nReact 16.8\n\n\n  \n    Context API:\n用於在組件樹中傳遞數據,無需顯式地通過 props 傳遞。\n  \n  \n    useReducer Hook:\n提供了類似 Redux 的狀態管理方式,適用於複雜的狀態邏輯。\n  \n  \n    Redux Toolkit:\n簡化了 Redux 的使用,提供了更好的開發體驗。\n  \n\n\nimport React, { useContext, useReducer } from 'react'\n\nconst StateContext = React.createContext()\n\nfunction reducer(state, action) {\n  // 狀態更新邏輯\n}\n\nfunction App() {\n  const [state, dispatch] = useReducer(reducer, initialState)\n  return (\n    &lt;StateContext.Provider value={ state, dispatch }&gt;\n      {/* 子組件 */}\n    &lt;/StateContext.Provider&gt;\n  )\n}\n\n\n代碼分割和懶加載\n\nVue 3\n\n\n  \n    異步組件:\nVue 3 提供了 defineAsyncComponent 方法來創建異步組件。\n  \n  \n    動態導入:\n結合 Webpack 的動態導入功能,可以實現路由級別的代碼分割。\n  \n\n\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() =&gt;\n  import('./components/AsyncComponent.vue')\n)\n\n\nReact 16.8\n\n\n  \n    React.lazy:\n用於動態導入組件。\n  \n  \n    Suspense:\n用於處理異步操作,如數據獲取或代碼分割。\n  \n\n\nimport React, { Suspense, lazy } from 'react'\n\nconst LazyComponent = lazy(() =&gt; import('./LazyComponent'))\n\nfunction App() {\n  return (\n    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;\n      &lt;LazyComponent /&gt;\n    &lt;/Suspense&gt;\n  )\n}\n\n\n服務端渲染 (SSR)\n\nVue 3\n\n\n  \n    改進的 SSR 架構:\nVue 3 的 SSR 實現更加高效,支持流式渲染。\n  \n  \n    Nuxt.js 3:\n基於 Vue 3 的服務端渲染框架,提供了豐富的功能和優化。\n  \n\n\nReact 16.8\n\n\n  \n    React Server Components:\n一種新的組件類型,可以在服務器上渲染,減少客戶端的 JavaScript 負載。\n  \n  \n    Next.js:\n流行的 React SSR 框架,提供了自動代碼分割、靜態生成等功能。\n  \n\n\n總結\n\nVue 3 和 React 16.8 都在性能優化、狀態管理和代碼組織方面做出了重大改進:\n\n\n  Vue 3 的靜態樹提升和 Proxy 響應式系統提供了出色的性能,而 React 的並發模式為複雜應用提供了更好的用戶體驗。\n  兩個框架都提供了強大的狀態管理解決方案,Vue 3 的 Composition API 和 React 的 Hooks 使得狀態邏輯更容易組織和重用。\n  在代碼分割和懶加載方面,兩個框架都提供了簡單易用的 API。\n  服務端渲染方面,Vue 3 和 React 都有成熟的解決方案和持續的創新。\n\n\n選擇使用哪個框架仍然取決於項目需求、團隊經驗和個人偏好。深入理解這些進階特性將幫助開發者在不同場景下做出更明智的選擇,並充分發揮所選框架的潛力。\n\n參考資料\n\n  Vue 3 性能優化\n  React 並發模式\n  Vue 3 SSR 指南\n  React Server Components\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2022-07-20-blog-vue3&React-2/"
    },{
      "image": "https://pinia.vuejs.org/logo.svg",
      "title": "Pinia 在 Vue 3 中的進階應用技巧",
      "date": "2023-01-09 00:00:00 +0800",
      
      "content": "\n  前言\n  Pinia 基礎回顧\n  進階應用技巧    \n      1. 組合式函數與 Pinia 結合\n      2. 訂閱 Store 變化\n      3. 插件系統\n      4. 持久化存儲\n      5. 模塊化和命名空間\n      6. 與 Vue Router 集成\n      7. 測試友好\n    \n  \n  總結\n  參考資料\n\n\n前言\n\nPinia 作為 Vue 3 的官方狀態管理庫,提供了簡潔、靈活且強大的 API。本文將深入探討 Pinia 在 Vue 3 中的進階應用技巧,幫助開發者更好地組織和管理應用狀態。\n\nPinia 基礎回顧\n\n在深入探討進階技巧之前,讓我們簡單回顧一下 Pinia 的基本用法:\n\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', {\n  state: () =&gt; ({ \n    count: 0 \n  }),\n  getters: {\n    doubleCount: (state) =&gt; state.count * 2,\n  },\n  actions: {\n    increment() {\n      this.count++\n    },\n  },\n})\n\n\n進階應用技巧\n\n1. 組合式函數與 Pinia 結合\n\nPinia 可以與 Vue 3 的組合式函數(Composition API)完美結合,實現更靈活的狀態管理:\n\nimport { ref, computed } from 'vue'\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', () =&gt; {\n  const count = ref(0)\n  const doubleCount = computed(() =&gt; count.value * 2)\n  \n  function increment() {\n    count.value++\n  }\n\n  return { count, doubleCount, increment }\n})\n\n\n這種方式使得狀態邏輯更容易組織和重用。\n\n2. 訂閱 Store 變化\n\nPinia 允許訂閱 store 的變化,這對於日誌記錄、持久化等場景非常有用:\n\nconst unsubscribe = store.$subscribe((mutation, state) =&gt; {\nconsole.log(mutation.type)\nconsole.log(mutation.storeId)\nconsole.log(mutation.payload)\n})\n// 停止訂閱\nunsubscribe()\n\n\n3. 插件系統\n\nPinia 提供了強大的插件系統,可以擴展 store 的功能:\n\nimport { createPinia } from 'pinia'\n\nfunction myPiniaPlugin(context) {\n  return {\n    ...context,\n    $reset() {\n      // 自定義重置邏輯\n    }\n  }\n}\n\nconst pinia = createPinia()\npinia.use(myPiniaPlugin)\n\n\n4. 持久化存儲\n\n結合插件系統,我們可以輕鬆實現狀態的持久化存儲:\n\nimport { defineStore } from 'pinia'\n\nexport const useUserStore = defineStore('user', {\n  state: () =&gt; ({\n    name: '',\n    token: '',\n  }),\n  persist: {\n    enabled: true,\n    strategies: [\n      { storage: localStorage, paths: ['token'] },\n      { storage: sessionStorage, paths: ['name'] },\n    ],\n  },\n})\n\n\n5. 模塊化和命名空間\n\nPinia 原生支持模塊化,無需額外配置:\n\n// stores/user.js\nexport const useUserStore = defineStore('user', { ... })\n// stores/product.js\nexport const useProductStore = defineStore('product', { ... })\n// 使用\nimport { useUserStore, useProductStore } from '@/stores'\nconst userStore = useUserStore()\nconst productStore = useProductStore()\n\n\n6. 與 Vue Router 集成\n\nPinia 可以與 Vue Router 無縫集成,實現基於路由的狀態管理:\n\nimport { useRoute } from 'vue-router'\nimport { defineStore } from 'pinia'\nexport const usePageStore = defineStore('page', () =&gt; {\nconst route = useRoute()\nconst pageTitle = computed(() =&gt; route.meta.title || 'Default Title')\nreturn { pageTitle }\n})\n\n\n7. 測試友好\n\nPinia 的設計使得單元測試變得簡單:\n\nimport { setActivePinia, createPinia } from 'pinia'\nimport { useCounterStore } from './counter'\n\ndescribe('Counter Store', () =&gt; {\n  beforeEach(() =&gt; {\n    setActivePinia(createPinia())\n  })\n\n  it('increments', () =&gt; {\n    const store = useCounterStore()\n    expect(store.count).toBe(0)\n    store.increment()\n    expect(store.count).toBe(1)\n  })\n})\n\n\n總結\n\nPinia 在 Vue 3 中提供了強大而靈活的狀態管理解決方案:\n\n\n  與組合式 API 的無縫集成使得狀態邏輯更易組織和重用。\n  訂閱機制和插件系統提供了強大的擴展能力。\n  原生支持模塊化,無需額外配置。\n  與 Vue Router 的集成使得基於路由的狀態管理變得簡單。\n  良好的測試支持有助於提高代碼質量。\n\n\n通過掌握這些進階技巧,開發者可以更好地利用 Pinia 來構建可維護、高性能的 Vue 3 應用。\n\n參考資料\n\n  Pinia 官方文檔\n  Vue 3 文檔\n  Vue Router 文檔\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2023-01-09-blog-vue3&Pinia/"
    },{
      "image": "https://cdn.quasar.dev/logo-v2/svg/logo.svg",
      "title": "Quasar 與 Vue 3 中的進階應用技巧",
      "date": "2023-02-02 00:00:00 +0800",
      
      "content": "\n  前言\n  Quasar 基礎回顧\n  進階應用技巧    \n      1. 使用 Quasar 插件\n      2. 自定義主題\n      3. 使用 Quasar CLI\n      4. 利用 Quasar 的響應式工具\n      5. 使用 Quasar 的 SSR 功能\n      6. 集成 Quasar 與 Pinia\n      7. 使用 Quasar 的 App Extensions\n    \n  \n  總結\n  參考資料\n\n\n前言\n\nQuasar 是一個基於 Vue 3 的強大 UI 框架,提供了豐富的組件和工具,可以快速構建高質量的跨平台應用。本文將深入探討 Quasar 在 Vue 3 中的進階應用技巧,幫助開發者更好地利用 Quasar 框架的特性。\n\nQuasar 基礎回顧\n\n在深入探討進階技巧之前,讓我們簡單回顧一下 Quasar 的基本用法:\n\n&lt;template&gt;\n  &lt;q-page class=\"flex flex-center\"&gt;\n    &lt;q-btn color=\"primary\" label=\"Click me\" @click=\"counter++\" /&gt;\n    &lt;p&gt;You've clicked  times.&lt;/p&gt;\n  &lt;/q-page&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const counter = ref(0)\n    return { counter }\n  }\n}\n&lt;/script&gt;\n\n\n進階應用技巧\n\n1. 使用 Quasar 插件\n\nQuasar 提供了許多有用的插件,可以輕鬆集成到 Vue 3 應用中:\n\n// quasar.conf.js\nreturn {\n  framework: {\n    plugins: ['Notify', 'Dialog']\n  }\n}\n\n// 在組件中使用\nimport { useQuasar } from 'quasar'\n\nexport default {\n  setup() {\n    const $q = useQuasar()\n    \n    function showNotification() {\n      $q.notify({\n        message: 'Hello!',\n        color: 'positive'\n      })\n    }\n\n    return { showNotification }\n  }\n}\n\n\n2. 自定義主題\n\nQuasar 允許輕鬆自定義應用的主題:\n\n// quasar.variables.scss\n$primary   : #1976D2;\n$secondary : #26A69A;\n$accent    : #9C27B0;\n\n$dark      : #1D1D1D;\n\n$positive  : #21BA45;\n$negative  : #C10015;\n$info      : #31CCEC;\n$warning   : #F2C037;\n\n\n3. 使用 Quasar CLI\n\nQuasar CLI 提供了強大的開發工具:\n\n# 創建新項目\nquasar create my-project\n\n# 添加 PWA 支持\nquasar mode add pwa\n\n# 運行開發服務器\nquasar dev\n\n# 構建生產版本\nquasar build\n\n\n4. 利用 Quasar 的響應式工具\n\nQuasar 提供了豐富的響應式工具:\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div class=\"gt-sm\"&gt;只在大屏幕上顯示&lt;/div&gt;\n    &lt;div class=\"lt-md\"&gt;只在小屏幕上顯示&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { useQuasar } from 'quasar'\n\nexport default {\n  setup() {\n    const $q = useQuasar()\n    console.log($q.screen.gt.sm) // 是否大於小屏幕\n  }\n}\n&lt;/script&gt;\n\n\n5. 使用 Quasar 的 SSR 功能\n\nQuasar 支持服務器端渲染 (SSR):\n\n// quasar.conf.js\nmodule.exports = function (ctx) {\n  return {\n    ssr: {\n      pwa: true\n    }\n  }\n}\n\n\n6. 集成 Quasar 與 Pinia\n\nQuasar 可以與 Pinia 無縫集成:\n\n// src/stores/counter.js\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', {\n  state: () =&gt; ({\n    count: 0\n  }),\n  actions: {\n    increment() {\n      this.count++\n    }\n  }\n})\n\n// 在組件中使用\nimport { useCounterStore } from 'src/stores/counter'\n\nexport default {\n  setup() {\n    const counterStore = useCounterStore()\n    return { counterStore }\n  }\n}\n\n\n7. 使用 Quasar 的 App Extensions\n\nQuasar App Extensions 可以擴展項目功能:\n\n# 添加 Dotenv 擴展\nquasar ext add @quasar/dotenv\n\n# 使用擴展\nimport { config } from '@quasar/dotenv'\nconsole.log(config.MY_API_KEY)\n\n\n總結\n\nQuasar 在 Vue 3 中提供了強大而靈活的開發解決方案:\n\n\n  豐富的 UI 組件和插件系統大大提高了開發效率。\n  自定義主題功能使得應用風格靈活可控。\n  Quasar CLI 提供了完整的開發工具鏈。\n  響應式設計工具使得跨平台開發變得簡單。\n  SSR 支持有助於提升應用性能和 SEO。\n  與 Pinia 等 Vue 生態系統的無縫集成。\n  App Extensions 系統允許進一步擴展功能。\n\n\n通過掌握這些進階技巧,開發者可以充分利用 Quasar 框架的優勢,構建高效、美觀、跨平台的 Vue 3 應用。\n\n參考資料\n\n  Quasar 官方文檔\n  Vue 3 文檔\n  Pinia 文檔\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2023-02-02-blog-vue3&Quasar-1/"
    },{
      "image": "https://cdn.quasar.dev/logo-v2/svg/logo.svg",
      "title": "Quasar 與 Vue 3 的進階應用技巧",
      "date": "2023-02-13 00:00:00 +0800",
      
      "content": "\n  前言\n  Vue 3 在 Quasar 中的基礎應用\n  Vue 3 在 Quasar 中的進階應用技巧    \n      1. 使用組合式 API\n      2. 使用 Teleport 組件\n      3. 使用 Suspense 組件\n      4. 使用 Provide/Inject\n      5. 使用 Quasar 的響應式工具與 Vue 3 的 reactive\n      6. 使用 Quasar 插件與 Vue 3 的生命週期鉤子\n    \n  \n  總結\n  參考資料\n\n\n前言\n\nQuasar 是一個強大的 UI 框架,完全支持 Vue 3。本文將深入探討在 Quasar 中使用 Vue 3 的進階技巧,幫助開發者更好地利用 Vue 3 的新特性。\n\nVue 3 在 Quasar 中的基礎應用\n\n首先,讓我們回顧一下 Vue 3 在 Quasar 中的基本用法:\n\n&lt;template&gt;\n  &lt;q-page class=\"flex flex-center\"&gt;\n    &lt;q-btn color=\"primary\" label=\"點擊我\" @click=\"increment\" /&gt;\n    &lt;p&gt;你已經點擊了 9 次。&lt;/p&gt;\n  &lt;/q-page&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    const increment = () =&gt; count.value++\n    return { count, increment }\n  }\n}\n&lt;/script&gt;\n\n\nVue 3 在 Quasar 中的進階應用技巧\n\n1. 使用組合式 API\n\nVue 3 的組合式 API 在 Quasar 中可以充分發揮:\n\n&lt;script&gt;\nimport { ref, computed, onMounted } from 'vue'\nimport { useQuasar } from 'quasar'\n\nexport default {\n  setup() {\n    const $q = useQuasar()\n    const count = ref(0)\n    const doubleCount = computed(() =&gt; count.value * 2)\n\n    const increment = () =&gt; {\n      count.value++\n      $q.notify({ message: '計數增加了!' })\n    }\n\n    onMounted(() =&gt; {\n      console.log('組件已掛載')\n    })\n\n    return { count, doubleCount, increment }\n  }\n}\n&lt;/script&gt;\n\n\n2. 使用 Teleport 組件\n\nVue 3 的 Teleport 組件在 Quasar 中也能很好地工作:\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;teleport to=\"body\"&gt;\n      &lt;q-dialog v-model=\"showDialog\"&gt;\n        &lt;q-card&gt;\n          &lt;q-card-section&gt;\n            &lt;div class=\"text-h6\"&gt;對話框內容&lt;/div&gt;\n          &lt;/q-card-section&gt;\n        &lt;/q-card&gt;\n      &lt;/q-dialog&gt;\n    &lt;/teleport&gt;\n    &lt;q-btn label=\"顯示對話框\" @click=\"showDialog = true\" /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const showDialog = ref(false)\n    return { showDialog }\n  }\n}\n&lt;/script&gt;\n\n\n3. 使用 Suspense 組件\n\nSuspense 組件可以優雅地處理異步組件:\n\n&lt;template&gt;\n  &lt;suspense&gt;\n    &lt;template #default&gt;\n      &lt;async-component /&gt;\n    &lt;/template&gt;\n    &lt;template #fallback&gt;\n      &lt;q-spinner-dots color=\"primary\" size=\"3em\" /&gt;\n    &lt;/template&gt;\n  &lt;/suspense&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { defineAsyncComponent } from 'vue'\n\nexport default {\n  components: {\n    AsyncComponent: defineAsyncComponent(() =&gt; import('./AsyncComponent.vue'))\n  }\n}\n&lt;/script&gt;\n\n\n4. 使用 Provide/Inject\n\nProvide 和 Inject 在 Quasar 應用中可以實現跨組件通信:\n\n// 父組件\nimport { provide } from 'vue'\nimport { useQuasar } from 'quasar'\n\nexport default {\n  setup() {\n    const $q = useQuasar()\n    provide('notifyService', {\n      success: (message) =&gt; $q.notify({ type: 'positive', message })\n    })\n  }\n}\n\n// 子組件\nimport { inject } from 'vue'\n\nexport default {\n  setup() {\n    const notifyService = inject('notifyService')\n    const showSuccess = () =&gt; notifyService.success('操作成功!')\n    return { showSuccess }\n  }\n}\n\n\n5. 使用 Quasar 的響應式工具與 Vue 3 的 reactive\n\n結合 Quasar 的響應式工具和 Vue 3 的 reactive:\n\nimport { reactive, computed } from 'vue'\nimport { useQuasar } from 'quasar'\n\nexport default {\n  setup() {\n    const $q = useQuasar()\n    const state = reactive({\n      count: 0,\n      isLargeScreen: computed(() =&gt; $q.screen.gt.sm)\n    })\n\n    return { state }\n  }\n}\n\n\n6. 使用 Quasar 插件與 Vue 3 的生命週期鉤子\n\n結合 Quasar 插件和 Vue 3 的生命週期鉤子:\n\nimport { onMounted, onUnmounted } from 'vue'\nimport { useQuasar } from 'quasar'\n\nexport default {\n  setup() {\n    const $q = useQuasar()\n    let notifyInstance = null\n\n    onMounted(() =&gt; {\n      notifyInstance = $q.notify({\n        message: '歡迎!',\n        timeout: 0\n      })\n    })\n\n    onUnmounted(() =&gt; {\n      if (notifyInstance) {\n        notifyInstance()\n      }\n    })\n  }\n}\n\n\n總結\n\n在 Quasar 中使用 Vue 3 的進階技巧可以大大提升開發效率和應用性能:\n\n\n  組合式 API 提供了更靈活的代碼組織方式。\n  Teleport 組件可以更好地控制 DOM 結構。\n  Suspense 組件簡化了異步組件的處理。\n  Provide/Inject 實現了更優雅的跨組件通信。\n  結合 Quasar 的響應式工具和 Vue 3 的 reactive 可以創建更強大的響應式系統。\n  Quasar 插件與 Vue 3 的生命週期鉤子結合使用,可以更好地管理資源。\n\n\n通過掌握這些進階技巧,開發者可以充分利用 Vue 3 在 Quasar 中的優勢,構建高效、靈活的應用。\n\n參考資料\n\n  Quasar 官方文檔\n  Vue 3 文檔\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2023-02-13-blog-vue3&Quasar-2/"
    },{
      "image": "https://miro.medium.com/max/1400/1*HSisLuifMO6KbLfPOKtLow.jpeg",
      "title": "React 18 的重點特性與應用",
      "date": "2023-03-03 00:00:00 +0800",
      
      "content": "\n  前言\n  React 18 的重點特性    \n      1. Concurrent Mode\n      2. Automatic Batching\n      3. Suspense for Data Fetching\n      4. 新的 Hooks\n      5. 改進的 SSR 和 Hydration\n    \n  \n  總結\n  參考資料\n\n\n前言\n\nReact 18 帶來了許多重要的更新和改進，這些新特性旨在提升開發者的生產力和應用的性能。本文將介紹 React 18 的一些重點特性，並展示如何在實際應用中利用它們。\n\nReact 18 的重點特性\n\n1. Concurrent Mode\n\nConcurrent Mode 是 React 18 的一個重要特性，它允許 React 更高效地處理多任務，提升應用的響應速度。\n\nimport React, { useState, useTransition } from 'react';\n\nfunction App() {\n  const [isPending, startTransition] = useTransition();\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =&gt; {\n    startTransition(() =&gt; {\n      setCount(c =&gt; c + 1);\n    });\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;計數: {count}&lt;/h1&gt;\n      &lt;button onClick={handleClick} disabled={isPending}&gt;\n        {isPending ? '更新中...' : '增加'}\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n2. Automatic Batching\n\nReact 18 引入了自動批處理功能，這意味著多個狀態更新將被自動批處理，以減少重新渲染次數，提高性能。\n\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  const handleClick = () =&gt; {\n    setCount(c =&gt; c + 1);\n    setText('計數已更新');\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;計數: {count}&lt;/h1&gt;\n      &lt;p&gt;{text}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;增加&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n3. Suspense for Data Fetching\n\nReact 18 擴展了 Suspense 的功能，現在可以用於數據加載，這使得處理異步操作更加簡單和直觀。\n\nimport React, { Suspense } from 'react';\n\nconst DataComponent = React.lazy(() =&gt; import('./DataComponent'));\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;React 18 的重點特性&lt;/h1&gt;\n      &lt;Suspense fallback={&lt;div&gt;加載中...&lt;/div&gt;}&gt;\n        &lt;DataComponent /&gt;\n      &lt;/Suspense&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n4. 新的 Hooks\n\nReact 18 引入了一些新的 Hooks，如 useTransition 和 useDeferredValue，這些 Hooks 提供了更多的功能和靈活性。\n\nimport React, { useState, useDeferredValue } from 'react';\n\nfunction App() {\n  const [value, setValue] = useState('');\n  const deferredValue = useDeferredValue(value);\n\n  return (\n    &lt;div&gt;\n      &lt;input value={value} onChange={e =&gt; setValue(e.target.value)} /&gt;\n      &lt;p&gt;延遲值: {deferredValue}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n5. 改進的 SSR 和 Hydration\n\nReact 18 改進了服務器端渲染（SSR）和水合（Hydration）過程，使得應用加載更快。\n\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport App from './App';\n\nconst html = ReactDOMServer.renderToString(&lt;App /&gt;);\nconsole.log(html);\n\n\n總結\n\nReact 18 帶來了許多強大的新特性和改進：\n\n\n  Concurrent Mode 提升了應用的響應速度。\n  Automatic Batching 減少了重新渲染次數。\n  Suspense for Data Fetching 使異步操作更加簡單。\n  新的 Hooks 提供了更多的功能和靈活性。\n  改進的 SSR 和 Hydration 使應用加載更快。\n\n\n通過掌握這些新特性，開發者可以充分利用 React 18 的優勢，構建高效、靈活的應用。\n\n參考資料\n\n  React 官方文檔\n  React 18 發布公告\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2023-03-03-blog-react18-1/"
    },{
      "image": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSREpZ70jN673LVo1EE5S2uQJePHhk-dl9M_A&s",
      "title": "Vue 3 與 Monorepo 的實際應用",
      "date": "2023-03-08 00:00:00 +0800",
      
      "content": "\n  前言\n  Monorepo 簡介\n  設置 Monorepo    \n      1. 初始化 Nx 工作區\n      2. 添加 Vue 應用\n      3. 添加 Vue 庫\n    \n  \n  在 Monorepo 中使用 Vue 3    \n      1. Composition API\n      2. Teleport\n      3. Suspense\n    \n  \n  總結\n  參考資料\n\n\n前言\n\n在現代前端開發中，Monorepo 已經成為管理大型代碼庫的一種流行方式。Vue 3 帶來了許多新特性，這些特性在 Monorepo 中的應用可以進一步提升開發效率和應用性能。本文將介紹如何在 Monorepo 中實際應用 Vue 3。\n\nMonorepo 簡介\n\nMonorepo 是指將多個項目存放在同一個代碼庫中，這樣可以更好地管理依賴關係、共享代碼和統一配置。常見的 Monorepo 工具有 Lerna 和 Nx。\n\n設置 Monorepo\n\n首先，我們需要設置一個 Monorepo。這裡我們使用 Nx 作為示例。\n\n1. 初始化 Nx 工作區\nnpx create-nx-workspace@latest my-workspace\ncd my-workspace\n\n\n2. 添加 Vue 應用\n\nnx generate @nx-plus/vue:application my-app\n\n\n3. 添加 Vue 庫\n\nnx generate @nx-plus/vue:library my-lib\n\n\n在 Monorepo 中使用 Vue 3\n\n1. Composition API\n\n在 Monorepo 中，我們可以在應用和庫中使用 Vue 3 的 Composition API 來提升開發體驗。\n\n&lt;!-- apps/my-app/src/App.vue --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;計數: 9&lt;/h1&gt;\n    &lt;button @click=\"increment\"&gt;增加&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from 'vue';\n\nconst count = ref(0);\n\nfunction increment() {\n  count.value++;\n}\n&lt;/script&gt;\n\n\n2. Teleport\n\nTeleport 功能可以在 Monorepo 中的多個應用和庫中使用，以便更靈活地管理 DOM 結構。\n\n&lt;!-- libs/my-lib/src/lib/MyLib.vue --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;計數: 9&lt;/h1&gt;\n    &lt;p&gt;&lt;/p&gt;\n    &lt;button @click=\"handleClick\"&gt;增加&lt;/button&gt;\n    &lt;teleport to=\"body\"&gt;\n      &lt;div class=\"modal\"&gt;這是一個模態框&lt;/div&gt;\n    &lt;/teleport&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref } from 'vue';\n\nconst count = ref(0);\nconst text = ref('');\n\nfunction handleClick() {\n  count.value++;\n  text.value = '計數已更新';\n}\n&lt;/script&gt;\n\n\n3. Suspense\n\n在 Monorepo 中，我們可以使用 Suspense 來處理數據加載，這使得異步操作更加簡單和直觀。\n\n&lt;!-- apps/my-app/src/App.vue --&gt;\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;Vue 3 與 Monorepo&lt;/h1&gt;\n    &lt;Suspense&gt;\n      &lt;template #default&gt;\n        &lt;DataComponent /&gt;\n      &lt;/template&gt;\n      &lt;template #fallback&gt;\n        &lt;div&gt;加載中...&lt;/div&gt;\n      &lt;/template&gt;\n    &lt;/Suspense&gt;\n    &lt;MyLib /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { defineAsyncComponent } from 'vue';\nimport MyLib from '@my-workspace/my-lib';\n\nconst DataComponent = defineAsyncComponent(() =&gt; import('./DataComponent.vue'));\n&lt;/script&gt;\n\n\n總結\n\n通過在 Monorepo 中應用 Vue 3 的新特性，我們可以顯著提升開發效率和應用性能：\n\n\n  Composition API 提升了開發體驗。\n  Teleport 提供了更靈活的 DOM 管理。\n  Suspense 使異步操作更加簡單。\n\n\n這些特性在 Monorepo 中的應用，讓我們能夠更好地管理大型代碼庫，實現高效的開發流程。\n\n參考資料\n\n  Vue 官方文檔\n  Nx 官方文檔\n  Vue 3 發布公告\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2023-03-08-blog-Monorepo&vue3-1/"
    },{
      "image": "https://miro.medium.com/max/1400/1*HSisLuifMO6KbLfPOKtLow.jpeg",
      "title": "React 18 與 Monorepo 的實際應用",
      "date": "2023-03-16 00:00:00 +0800",
      
      "content": "\n  前言\n  Monorepo 簡介\n  設置 Monorepo    \n      1. 初始化 Nx 工作區\n      2. 添加 React 應用\n      3. 添加 React 庫\n    \n  \n  在 Monorepo 中使用 React 18    \n      1. Concurrent Mode\n      2. Automatic Batching\n      3. Suspense for Data Fetching\n    \n  \n  總結\n  參考資料\n\n\n前言\n\n在現代前端開發中，Monorepo 已經成為管理大型代碼庫的一種流行方式。React 18 帶來了許多新特性，這些特性在 Monorepo 中的應用可以進一步提升開發效率和應用性能。本文將介紹如何在 Monorepo 中實際應用 React 18。\n\nMonorepo 簡介\n\nMonorepo 是指將多個項目存放在同一個代碼庫中，這樣可以更好地管理依賴關係、共享代碼和統一配置。常見的 Monorepo 工具有 Lerna 和 Nx。\n\n設置 Monorepo\n\n首先，我們需要設置一個 Monorepo。這裡我們使用 Nx 作為示例。\n\n1. 初始化 Nx 工作區\nbash\nnpx create-nx-workspace@latest my-workspace\ncd my-workspace\n\n\n2. 添加 React 應用\n\nbash\nnx generate @nrwl/react:application my-app\n\n\n3. 添加 React 庫\n\nbash\nnx generate @nrwl/react:library my-lib\n\n\n在 Monorepo 中使用 React 18\n\n1. Concurrent Mode\n\n在 Monorepo 中，我們可以在應用和庫中使用 React 18 的 Concurrent Mode 來提升性能。\n\n// apps/my-app/src/app/app.tsx\nimport React, { useState, useTransition } from 'react';\n\nfunction App() {\n  const [isPending, startTransition] = useTransition();\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =&gt; {\n    startTransition(() =&gt; {\n      setCount(c =&gt; c + 1);\n    });\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;計數: {count}&lt;/h1&gt;\n      &lt;button onClick={handleClick} disabled={isPending}&gt;\n        {isPending ? '更新中...' : '增加'}\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n2. Automatic Batching\n\n自動批處理功能可以在 Monorepo 中的多個應用和庫中使用，以減少重新渲染次數。\n\n// libs/my-lib/src/lib/my-lib.tsx\nimport React, { useState } from 'react';\n\nexport function MyLib() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  const handleClick = () =&gt; {\n    setCount(c =&gt; c + 1);\n    setText('計數已更新');\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;計數: {count}&lt;/h1&gt;\n      &lt;p&gt;{text}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;增加&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\n\n3. Suspense for Data Fetching\n\n在 Monorepo 中，我們可以使用 Suspense 來處理數據加載，這使得異步操作更加簡單和直觀。\n\n// apps/my-app/src/app/app.tsx\nimport React, { Suspense } from 'react';\nimport { MyLib } from '@my-workspace/my-lib';\n\nconst DataComponent = React.lazy(() =&gt; import('./data-component'));\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;React 18 與 Monorepo&lt;/h1&gt;\n      &lt;Suspense fallback={&lt;div&gt;加載中...&lt;/div&gt;}&gt;\n        &lt;DataComponent /&gt;\n      &lt;/Suspense&gt;\n      &lt;MyLib /&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n總結\n\n通過在 Monorepo 中應用 React 18 的新特性，我們可以顯著提升開發效率和應用性能：\n\n\n  Concurrent Mode 提升了應用的響應速度。\n  Automatic Batching 減少了重新渲染次數。\n  Suspense for Data Fetching 使異步操作更加簡單。\n\n\n這些特性在 Monorepo 中的應用，讓我們能夠更好地管理大型代碼庫，實現高效的開發流程。\n\n參考資料\n\n  React 官方文檔\n  Nx 官方文檔\n  React 18 發布公告\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2023-03-16-blog-Monorepo&react18-1/"
    },{
      "image": "https://miro.medium.com/v2/resize:fit:2000/1*vQK4s0lOiK1ZkcXxFNIMDQ.png",
      "title": "Monorepo 與 Docker 的應用技巧",
      "date": "2023-04-25 00:00:00 +0800",
      
      "content": "\n  前言\n  Monorepo 簡介\n  Docker 簡介\n  設置 Monorepo 和 Docker    \n      1. 初始化 Nx 工作區\n      2. 添加 Vue 應用\n      3. 添加 Docker 支持\n      4. 創建 Docker Compose 文件\n    \n  \n  在 Monorepo 中使用 Docker    \n      1. 本地開發\n      2. 部署到生產環境\n    \n  \n  總結\n  參考資料\n\n\n前言\n\n在現代前端開發中，Monorepo 和 Docker 是兩個強大的工具。Monorepo 可以幫助我們更好地管理大型代碼庫，而 Docker 則提供了輕量級的容器化解決方案。本文將介紹如何將這兩者結合起來，提升開發效率和應用性能。\n\nMonorepo 簡介\n\nMonorepo 是指將多個項目存放在同一個代碼庫中，這樣可以更好地管理依賴關係、共享代碼和統一配置。常見的 Monorepo 工具有 Lerna 和 Nx。\n\nDocker 簡介\n\nDocker 是一個開源的平台，通過容器化技術來實現應用的快速部署和運行。它可以將應用及其依賴打包成一個輕量級、可移植的容器，從而實現跨環境的一致性。\n\n設置 Monorepo 和 Docker\n\n1. 初始化 Nx 工作區\n\n首先，我們需要設置一個 Monorepo。這裡我們使用 Nx 作為示例。\n\nnpx create-nx-workspace@latest my-workspace\ncd my-workspace\n\n\n2. 添加 Vue 應用\n\nnx generate @nx-plus/vue:application my-app\n\n\n3. 添加 Docker 支持\n\n在應用中添加 Docker 支持，首先需要創建一個 Dockerfile。\n\n&lt;!-- apps/my-app/Dockerfile --&gt;\n# 使用官方的 Node.js 圖像作為基礎圖像\nFROM node:16-alpine\n\n# 設置工作目錄\nWORKDIR /app\n\n# 複製 package.json 和 package-lock.json\nCOPY package*.json ./\n\n# 安裝依賴\nRUN npm install\n\n# 複製應用代碼\nCOPY . .\n\n# 構建應用\nRUN npm run build\n\n# 暴露應用運行的端口\nEXPOSE 3000\n\n# 啟動應用\nCMD [\"npm\", \"start\"]\n\n\n4. 創建 Docker Compose 文件\n\n為了更方便地管理多個容器，我們可以使用 Docker Compose。\n\n&lt;!-- docker-compose.yml --&gt;\nversion: '3.8'\nservices:\n  my-app:\n    build:\n      context: ./apps/my-app\n      dockerfile: Dockerfile\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - ./apps/my-app:/app\n    environment:\n      - NODE_ENV=development\n\n\n在 Monorepo 中使用 Docker\n\n1. 本地開發\n\n在本地開發中，我們可以使用 Docker Compose 來啟動應用。\n\ndocker-compose up --build\n\n\n2. 部署到生產環境\n\n在生產環境中，我們可以將應用打包成 Docker 映像，並推送到 Docker Hub 或其他容器託管服務。\n\n# 登錄到 Docker Hub\ndocker login\n\n# 構建 Docker 映像\ndocker build -t my-app:latest ./apps/my-app\n\n# 推送 Docker 映像\ndocker push my-app:latest\n\n\n總結\n\n通過將 Monorepo 和 Docker 結合，我們可以顯著提升開發效率和應用性能：\n\n\n  Monorepo 提供了更好的代碼管理和依賴管理。\n  Docker 提供了輕量級的容器化解決方案，實現跨環境的一致性。\n  Docker Compose 使得多容器應用的管理更加方便。\n\n\n這些應用技巧讓我們能夠更好地管理大型代碼庫，實現高效的開發和部署流程。\n\n參考資料\n\n  Nx 官方文檔\n  Docker 官方文檔\n  Docker Hub\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2023-04-25-blog-Monorepo&Docker/"
    },{
      "image": "https://miro.medium.com/max/1400/1*HSisLuifMO6KbLfPOKtLow.jpeg",
      "title": "React 19 的新特性與應用技巧",
      "date": "2024-04-16 00:00:00 +0800",
      
      "content": "\n  前言\n  React 19 的新特性    \n      1. Server Components\n      2. Concurrent Rendering\n      3. Automatic Batching\n      4. Improved SSR and Hydration\n      5. New Hooks\n    \n  \n  總結\n  參考資料\n\n\n前言\n\nReact 19 帶來了許多令人興奮的新特性和改進。本文將介紹這些新特性，並展示如何在實際應用中利用它們來提升開發效率和應用性能。\n\nReact 19 的新特性\n\n1. Server Components\n\nReact 19 引入了 Server Components，允許在服務器端渲染部分組件，減少客戶端的負擔。\n\n// ServerComponent.server.js\nimport React from 'react';\n\nexport default function ServerComponent() {\n  return &lt;div&gt;這是服務器端渲染的組件&lt;/div&gt;;\n}\n\n\n// App.js\nimport React from 'react';\nimport ServerComponent from './ServerComponent.server';\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;React 19 新特性&lt;/h1&gt;\n      &lt;ServerComponent /&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n2. Concurrent Rendering\n\nConcurrent Rendering 使得 React 可以更高效地處理多任務，提升應用的響應速度。\n\nimport React, { useState, useTransition } from 'react';\n\nfunction App() {\n  const [isPending, startTransition] = useTransition();\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =&gt; {\n    startTransition(() =&gt; {\n      setCount(c =&gt; c + 1);\n    });\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;計數: {count}&lt;/h1&gt;\n      &lt;button onClick={handleClick} disabled={isPending}&gt;\n        {isPending ? '更新中...' : '增加'}\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n3. Automatic Batching\n\nReact 19 自動批處理多個狀態更新，減少重新渲染次數，提高性能。\n\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  const handleClick = () =&gt; {\n    setCount(c =&gt; c + 1);\n    setText('計數已更新');\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;計數: {count}&lt;/h1&gt;\n      &lt;p&gt;{text}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;增加&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n4. Improved SSR and Hydration\n\nReact 19 改進了服務器端渲染（SSR）和水合（Hydration）過程，使得應用加載更快。\n\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport App from './App';\n\nconst html = ReactDOMServer.renderToString(&lt;App /&gt;);\nconsole.log(html);\n\n\n5. New Hooks\n\nReact 19 引入了新的 Hooks，如 useDeferredValue 和 useId，提供更多的功能和靈活性。\n\nimport React, { useState, useDeferredValue } from 'react';\n\nfunction App() {\n  const [value, setValue] = useState('');\n  const deferredValue = useDeferredValue(value);\n\n  return (\n    &lt;div&gt;\n      &lt;input value={value} onChange={e =&gt; setValue(e.target.value)} /&gt;\n      &lt;p&gt;延遲值: {deferredValue}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n總結\n\nReact 19 帶來了許多強大的新特性和改進：\n\n\n  Server Components 允許在服務器端渲染部分組件。\n  Concurrent Rendering 提升了應用的響應速度。\n  Automatic Batching 減少了重新渲染次數。\n  改進的 SSR 和 Hydration 使應用加載更快。\n  新的 Hooks 提供了更多的功能和靈活性。\n\n\n通過掌握這些新特性，開發者可以充分利用 React 19 的優勢，構建高效、靈活的應用。\n\n參考資料\n\n  React 官方文檔\n  React 19 發布公告\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2024-04-16-blog-react19-1/"
    },{
      "image": "https://miro.medium.com/max/1400/1*HSisLuifMO6KbLfPOKtLow.jpeg",
      "title": "React 19 進階技巧與最佳實踐",
      "date": "2024-04-27 00:00:00 +0800",
      
      "content": "\n  前言\n  進階技巧    \n      1. 使用 Server Components 優化性能\n      2. 利用 Concurrent Rendering 提升用戶體驗\n      3. 自動批處理狀態更新\n      4. 改進的 SSR 和 Hydration\n      5. 使用新 Hooks 提升開發效率\n    \n  \n  總結\n  參考資料\n\n\n前言\n\n在本文中，我們將探討 React 19 的一些進階技巧和最佳實踐，幫助開發者更好地利用這些新特性來構建高效、可維護的應用。\n\n進階技巧\n\n1. 使用 Server Components 優化性能\n\nServer Components 可以顯著減少客戶端的負擔，提升應用的性能。以下是如何在實際應用中使用 Server Components 的示例：\n\n// ServerComponent.server.js\nimport React from 'react';\n\nexport default function ServerComponent() {\n  return &lt;div&gt;這是服務器端渲染的組件&lt;/div&gt;;\n}\n\n\n// App.js\nimport React from 'react';\nimport ServerComponent from './ServerComponent.server';\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;React 19 進階技巧&lt;/h1&gt;\n      &lt;ServerComponent /&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n2. 利用 Concurrent Rendering 提升用戶體驗\n\nConcurrent Rendering 允許 React 更高效地處理多任務，提升應用的響應速度。以下是如何使用 useTransition 來實現平滑的用戶體驗：\n\nimport React, { useState, useTransition } from 'react';\n\nfunction App() {\n  const [isPending, startTransition] = useTransition();\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =&gt; {\n    startTransition(() =&gt; {\n      setCount(c =&gt; c + 1);\n    });\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;計數: {count}&lt;/h1&gt;\n      &lt;button onClick={handleClick} disabled={isPending}&gt;\n        {isPending ? '更新中...' : '增加'}\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n3. 自動批處理狀態更新\n\nReact 19 的自動批處理功能可以減少重新渲染次數，提高性能。以下是如何利用這一功能的示例：\n\nimport React, { useState } from 'react';\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  const handleClick = () =&gt; {\n    setCount(c =&gt; c + 1);\n    setText('計數已更新');\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;計數: {count}&lt;/h1&gt;\n      &lt;p&gt;{text}&lt;/p&gt;\n      &lt;button onClick={handleClick}&gt;增加&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n4. 改進的 SSR 和 Hydration\n\nReact 19 改進了 SSR 和 Hydration 過程，使得應用加載更快。以下是如何使用 ReactDOMServer 進行服務器端渲染的示例：\n\nimport React from 'react';\nimport ReactDOMServer from 'react-dom/server';\nimport App from './App';\n\nconst html = ReactDOMServer.renderToString(&lt;App /&gt;);\nconsole.log(html);\n\n\n5. 使用新 Hooks 提升開發效率\n\nReact 19 引入了新的 Hooks，如 useDeferredValue 和 useId，提供更多的功能和靈活性。以下是如何使用 useDeferredValue 的示例：\n\nimport React, { useState, useDeferredValue } from 'react';\n\nfunction App() {\n  const [value, setValue] = useState('');\n  const deferredValue = useDeferredValue(value);\n\n  return (\n    &lt;div&gt;\n      &lt;input value={value} onChange={e =&gt; setValue(e.target.value)} /&gt;\n      &lt;p&gt;延遲值: {deferredValue}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n\n\n總結\n\n通過掌握這些進階技巧和最佳實踐，開發者可以充分利用 React 19 的新特性，構建高效、靈活的應用：\n\n\n  使用 Server Components 優化性能。\n  利用 Concurrent Rendering 提升用戶體驗。\n  自動批處理狀態更新以提高性能。\n  改進的 SSR 和 Hydration 使應用加載更快。\n  使用新 Hooks 提升開發效率。\n\n\n參考資料\n\n  React 官方文檔\n  React 19 發布公告\n\n",
      "categories": ["blog"],
      "tags": [],
      
      "collection": "posts",
      "url": "/blog/2024-04-27-blog-react19-2/"
    },{
      "image": {"path":"/assets/img/projects/Website/website-01.jpg","srcset":{"1920w":"/assets/img/projects/Website/website-01.jpg","960w":"/assets/img/projects/Website/website-01.jpg","480w":"/assets/img/projects/Website/website-01.jpg"}},
      "title": "Website",
      "date": "2014-09-01 00:00:00 +0800",
      "description": "Website\n",
      "content": "Website\n\n\n\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/Website/"
    },{
      "image": {"path":"/assets/img/projects/KB/kb-v.jpg","srcset":{"1920w":"/assets/img/projects/KB/kb-v.jpg","960w":"/assets/img/projects/KB/kb-v.jpg","480w":"/assets/img/projects/KB/kb-v.jpg"}},
      "title": "KingBeauty",
      "date": "2015-06-01 00:00:00 +0800",
      "description": "KingBeauty\n",
      "content": "KingBeauty官方網站\n\n\n\n\n\n\n\n整形分類查詢資料庫\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/KB/"
    },{
      "image": {"path":"/assets/img/projects/Kingnet/k-01_1-2.png","srcset":{"1920w":"/assets/img/projects/Kingnet/k-01_1-2.png","960w":"/assets/img/projects/Kingnet/k-01_1-2.png","480w":"/assets/img/projects/Kingnet/k-01_1-2.png"}},
      "title": "KingNet",
      "date": "2017-06-01 00:00:00 +0800",
      "description": "KingNet線上健康諮詢網站\n",
      "content": "KingNet介紹\n\n\n\n\n\n\n\n\nKingNet官方網站\n\n\n\n\n\n\n\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/Kingnet/"
    },{
      "image": {"path":"/assets/img/projects/ADATA-HR/p-001.jpg","srcset":{"1920w":"/assets/img/projects/ADATA-HR/p-001.jpg","960w":"/assets/img/projects/ADATA-HR/p-001.jpg","480w":"/assets/img/projects/ADATA-HR/p-001.jpg"}},
      "title": "ADATA-HR-SYSTEM",
      "date": "2017-12-10 00:00:00 +0800",
      "description": "ADATA-HR-SYSTEM\n",
      "content": "漸層色票系統\n\n\n\n各部門系統簽核表單\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/ADATA-HR-SYSTEM/"
    },{
      "image": {"path":"/assets/img/projects/ADATA/adata-index01.png","srcset":{"1920w":"/assets/img/projects/ADATA/adata-index01.png","960w":"/assets/img/projects/ADATA/adata-index01.png","480w":"/assets/img/projects/ADATA/adata-index01.png"}},
      "title": "ADATA-OFFICIAL & EVENT",
      "date": "2018-03-01 00:00:00 +0800",
      "description": "ADATA-OFFICIAL &amp; EVENT\n",
      "content": "GAMING &amp; EVENT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n威剛官方網站\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/ADATA-OFFICIAL/"
    },{
      "image": {"path":"/assets/img/projects/APP-Drugs/d-02.png","srcset":{"1920w":"/assets/img/projects/APP-Drugs/d-02.png","960w":"/assets/img/projects/APP-Drugs/d-02.png","480w":"/assets/img/projects/APP-Drugs/d-02.png"}},
      "title": "APP-Inquiry & Medication Guide",
      "date": "2019-01-01 00:00:00 +0800",
      "description": "Inquiry &amp; Medication Guide\n",
      "content": "Overviews New Version\n\n\n\nEarlier Version\n\n\n\nHealth News\n\n\n\n\n\n\nInquiry（NLP）\n\n\n\n\nMedication\n\n\n\n\n\n\nCategory\n\n\n\n\nSearching\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/Medication/"
    },{
      "image": {"path":"/assets/img/projects/EMCC/EMCC_1.png","srcset":{"1920w":"/assets/img/projects/EMCC/EMCC_1.png","960w":"/assets/img/projects/EMCC/EMCC_1.png","480w":"/assets/img/projects/EMCC/EMCC_1.png"}},
      "title": "Human Resources Management",
      "date": "2019-01-10 00:00:00 +0800",
      "description": "Human Resources Management\n",
      "content": "Human Resources Management\n\nEMCC Talent Management is a comprehensive human resources management system designed to streamline and optimize various HR processes within organizations. This innovative platform offers a wide range of features to support the entire employee lifecycle, from recruitment and onboarding to performance management and career development.\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "categories": ["Human Resources","Management"],
      "tags": ["Human Resources","Management"],
      
      "collection": "projects",
      "url": "/projects/EMCC/"
    },{
      "image": {"path":"/assets/img/projects/Join/join_3.jpg","srcset":{"1920w":"/assets/img/projects/Join/join_3.jpg","960w":"/assets/img/projects/Join/join_3.jpg","480w":"/assets/img/projects/Join/join_3.jpg"}},
      "title": "Join 揪癮客 電商",
      "date": "2019-05-05 00:00:00 +0800",
      "description": "Join 揪癮客 電商\n",
      "content": "Join E-commerce\n\nJoin is an innovative e-commerce platform designed to meet the diverse needs of modern consumers. This platform not only offers a traditional online shopping experience but also integrates social elements and personalized recommendation features, creating a unique shopping environment for users.\n\nThe name “Join” implies “participation” or “engagement,” perfectly encapsulating the platform’s core concept: bringing shopping enthusiasts together to explore and share the joy of shopping.\n\nKey features of the platform include:\n\n\n  \n    Social Shopping Experience: Users can create shopping circles and share favorite products and shopping lists with friends.\n  \n  \n    Intelligent Recommendation System: Provides personalized product recommendations based on users’ browsing and purchase history.\n  \n  \n    Interactive Review System: Users can rate and comment on products, helping other consumers make informed purchasing decisions.\n  \n  \n    Limited-Time Special Offers: Regular promotional events are held to attract frequent user visits to the platform.\n  \n  \n    Diverse Payment Options: Supports multiple payment methods, offering users a convenient checkout experience.\n  \n\n\nThe Join e-commerce platform aims to create a vibrant and interactive online shopping community, making shopping not just a consumer behavior, but also a social experience and lifestyle.\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/Join/"
    },{
      "image": {"path":"/assets/img/projects/DataEngine/DE_11.jpg","srcset":{"1920w":"/assets/img/projects/DataEngine/DE_11.jpg","960w":"/assets/img/projects/DataEngine/DE_11.jpg","480w":"/assets/img/projects/DataEngine/DE_11.jpg"}},
      "title": "DataEngine",
      "date": "2020-08-20 00:00:00 +0800",
      "description": "DataEngine\n",
      "content": "DataEngine\n\nDataEngine is a powerful data processing and analysis platform designed to handle large-scale, complex datasets. It not only integrates advanced data mining algorithms, machine learning models, and visualization tools but also seamlessly connects with third-party social media data from platforms such as Facebook and LINE. This capability enables DataEngine to provide comprehensive data solutions, especially in analyzing potential customer groups and optimizing ad placements.\n\nDataEngine efficiently processes both structured and unstructured data, supporting real-time data stream processing and batch data analysis. By analyzing user behavior, preferences, and interaction patterns on social media, DataEngine can identify and target potential customer groups, providing valuable market insights for businesses.\n\n\n\n\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/DataEngine/"
    },{
      "image": {"path":"/assets/img/projects/emers/001.png","srcset":{"1920w":"/assets/img/projects/emers/001.png","960w":"/assets/img/projects/emers/001.png","480w":"/assets/img/projects/emers/001.png"}},
      "title": "NIKE GOLF SYSTEM",
      "date": "2020-11-30 00:00:00 +0800",
      "description": "Emers International Corporation\n",
      "content": "系統規劃涵蓋 Dashboard、圖片上傳、訂單匯出、系統通知、商品瀏覽…等等。\n\n\n\nB2B客戶可線上瀏覽最新商品，或預購非當季款式。\n\n\n用戶透過介面，將庫存系統匯出的庫存資料Excel表單，匯入數據系統整合銷售端。\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/nike-golf-system/"
    },{
      "image": {"path":"/assets/img/projects/nike-golf/p-004-2.png","srcset":{"1920w":"/assets/img/projects/nike-golf/p-004-2.png","960w":"/assets/img/projects/nike-golf/p-004-2.png","480w":"/assets/img/projects/nike-golf/p-004-2.png"}},
      "title": "NIKE GOLF TW",
      "date": "2020-11-30 00:00:00 +0800",
      "description": "Emers International Corporation\n",
      "content": "台灣區銷售官網\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "categories": ["NIKE","GOLF"],
      "tags": ["NIKE","GOLF"],
      
      "collection": "projects",
      "url": "/projects/nike-golf/"
    },{
      "image": {"path":"/assets/img/projects/ASH/001.png","srcset":{"1920w":"/assets/img/projects/ASH/001.png","960w":"/assets/img/projects/ASH/001.png","480w":"/assets/img/projects/ASH/001.png"}},
      "title": "NIKE.vn",
      "date": "2020-11-30 00:00:00 +0800",
      "description": "Emers International Corporation\n",
      "content": "桌機版\n\n\n\nRWD手機版\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/nike-vn/"
    },{
      "image": {"path":"/assets/img/projects/APP-Prototype/app-01.jpg","srcset":{"1920w":"/assets/img/projects/APP-Prototype/app-01.jpg","960w":"/assets/img/projects/APP-Prototype/app-01.jpg","480w":"/assets/img/projects/APP-Prototype/app-01.jpg"}},
      "title": "App-Prototype",
      "date": "2022-08-01 00:00:00 +0800",
      "description": "App-Prototype\n",
      "content": "App-Prototype\n\n\n\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/APP-Prototype/"
    },{
      "image": {"path":"/assets/img/projects/IDC/IDC_6.jpg","srcset":{"1920w":"/assets/img/projects/IDC/IDC_6.jpg","960w":"/assets/img/projects/IDC/IDC_6.jpg","480w":"/assets/img/projects/IDC/IDC_6.jpg"}},
      "title": "IDC",
      "date": "2023-09-29 00:00:00 +0800",
      "description": "IDC\n",
      "content": "NovoDS Interactive Playlist Editor\n\nThe NovoDS Interactive Playlist Editor is a powerful tool designed specifically for digital signage systems. It allows users to easily create, edit, and manage complex multimedia playlists, supporting various content types including images, videos, audio, and web pages. This editor features an intuitive drag-and-drop interface, real-time preview functionality, flexible scheduling options, and seamless integration with various digital signage hardware. It is particularly well-suited for applications that require frequent content updates, such as retail, corporate communications, and public information displays.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/IDC/"
    },{
      "image": {"path":"/assets/img/projects/Sharing&Polling/sharing_00.jpg","srcset":{"1920w":"/assets/img/projects/Sharing&Polling/sharing_00.jpg","960w":"/assets/img/projects/Sharing&Polling/sharing_00.jpg","480w":"/assets/img/projects/Sharing&Polling/sharing_00.jpg"}},
      "title": "Sharing & Polling",
      "date": "2024-04-01 00:00:00 +0800",
      "description": "Sharing &amp; Polling\n",
      "content": "Sharing &amp; Polling\n\nSharing &amp; Polling is a versatile application that combines file sharing and polling functionalities. This application is designed to enhance team collaboration efficiency and increase engagement in decision-making processes.\n\nThe File Sharing feature enables users to easily transfer and share various types of files among team members, including documents, images, and videos. It offers an intuitive user interface and secure file transfer mechanisms, ensuring data security and privacy.\n\nFile Sharing\n\n\n\n\n\n\n\n\n\nPolling\n\n\n\n\n\n\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/Sharing&Polling/"
    },{
      "image": {"path":"/assets/img/projects/wb/wb_25.jpg","srcset":{"1920w":"/assets/img/projects/wb/wb_25.jpg","960w":"/assets/img/projects/wb/wb_25.jpg","480w":"/assets/img/projects/wb/wb_25.jpg"}},
      "title": "Whiteboard",
      "date": "2024-04-01 00:00:00 +0800",
      "description": "Whiteboard\n",
      "content": "NovoConnect.Cloud-Whiteboard\n\nNovoConnect.Cloud-Whiteboard is a powerful cloud-based collaborative whiteboard tool. It provides team members with a virtual shared space for real-time creative brainstorming, project planning, and remote teaching. This intuitive platform supports a variety of drawing tools, text input, image insertion, and file sharing, allowing users to easily express and communicate ideas. Its cloud-based nature ensures instant synchronization of all content, enabling seamless collaboration among team members regardless of their location.\n\nLogin &amp; Create Cloud Project\n\n\n\n\n\n\n\nEnter the Project &amp; Start to drawing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nShare the Project\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/wb/"
    },{
      "image": {"path":"/assets/img/projects/DRE/DRE_00.jpg","srcset":{"1920w":"/assets/img/projects/DRE/DRE_00.jpg","960w":"/assets/img/projects/DRE/DRE_00.jpg","480w":"/assets/img/projects/DRE/DRE_00.jpg"}},
      "title": "DRE-APP",
      "date": "2024-07-10 00:00:00 +0800",
      "description": "DRE-APP\n",
      "content": "Device registration express App (for Android)\n\nDevice Registration Express (DRE) is an efficient registration application designed specifically for Android devices. It streamlines the device registration process, offering users a quick and convenient experience. The DRE app features an intuitive user interface and supports multiple registration methods, including QR code scanning and manual serial number input. Additionally, it incorporates real-time verification functionality to ensure the accuracy of registration information. DRE is not only suitable for individual users but also serves as an ideal solution for businesses managing large numbers of devices, helping to improve work efficiency and accuracy in device management.\n\n\n\n\n\n\n\n\n\n\n",
      "categories": [],
      "tags": [],
      
      "collection": "projects",
      "url": "/projects/DRE-APP/"
    }
  ]
}

